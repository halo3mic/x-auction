{
  "address": "0x6075132C43BCb7792E475f3370c784295E42C30B",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_vault",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "_settlementChainRpc",
          "type": "string"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "PeekerReverted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "message",
          "type": "string"
        }
      ],
      "name": "SuaveError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "message",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "SuaveErrorWithData",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "auctionId",
          "type": "uint256"
        }
      ],
      "name": "AuctionCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "auctionId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "auctioneer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "hashedToken",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "payoutAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "until",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "payoutCollectionDuration",
          "type": "uint64"
        }
      ],
      "name": "AuctionCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint16",
          "name": "auctionId",
          "type": "uint16"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "winningBidId",
          "type": "uint32"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "taker",
              "type": "address"
            },
            {
              "internalType": "uint16",
              "name": "paymentNonce",
              "type": "uint16"
            },
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct AuctionPayout",
          "name": "payout",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "payoutSig",
          "type": "bytes"
        }
      ],
      "name": "AuctionSettled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint16",
          "name": "auctionId",
          "type": "uint16"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "bidId",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "bidder",
          "type": "address"
        }
      ],
      "name": "BidPlaced",
      "type": "event"
    },
    {
      "stateMutability": "nonpayable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "auctionMaster",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "auctions",
      "outputs": [
        {
          "internalType": "address",
          "name": "payoutAddress",
          "type": "address"
        },
        {
          "internalType": "enum AuctionStatus",
          "name": "status",
          "type": "uint8"
        },
        {
          "internalType": "Suave.DataId",
          "name": "tokenDataId",
          "type": "bytes16"
        },
        {
          "internalType": "bytes32",
          "name": "hashedToken",
          "type": "bytes32"
        },
        {
          "internalType": "uint32",
          "name": "bids",
          "type": "uint32"
        },
        {
          "internalType": "uint64",
          "name": "until",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "payoutCollectionDuration",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "auctioneer",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "winner",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "auctionId",
          "type": "uint256"
        }
      ],
      "name": "cancelAuction",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ccontrolInit",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "nextHash",
          "type": "bytes32"
        },
        {
          "internalType": "Suave.DataId",
          "name": "sBidId",
          "type": "bytes16"
        }
      ],
      "name": "ccontrolInitCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ccontrolIsInitialized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ccontrolOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "auctionId",
          "type": "uint16"
        },
        {
          "internalType": "address",
          "name": "bidder",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "bidAmount",
          "type": "uint256"
        }
      ],
      "name": "checkBidValidity",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "auctionId",
          "type": "uint16"
        }
      ],
      "name": "claimToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "confidentialConstructor",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "Suave.DataId",
          "name": "_pkDataId",
          "type": "bytes16"
        },
        {
          "internalType": "Suave.DataId",
          "name": "_bidCountDataId",
          "type": "bytes16"
        },
        {
          "internalType": "address",
          "name": "pkAddress",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "ccontrolInitCallback",
          "type": "bytes"
        }
      ],
      "name": "confidentialConstructorCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "auctionDuration",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "payoutCollectionDuration",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "payoutAddress",
              "type": "address"
            }
          ],
          "internalType": "struct NewAuctionArgs",
          "name": "auctionArgs",
          "type": "tuple"
        }
      ],
      "name": "createAuction",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "auctionDuration",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "payoutCollectionDuration",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "payoutAddress",
              "type": "address"
            }
          ],
          "internalType": "struct NewAuctionArgs",
          "name": "auctionArgs",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "tokenHash",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "auctioneer",
          "type": "address"
        },
        {
          "internalType": "Suave.DataId",
          "name": "tokenDataId",
          "type": "bytes16"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "key",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "nextHash",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ConfidentialControl.UnlockArgs",
          "name": "uArgs",
          "type": "tuple"
        }
      ],
      "name": "createAuctionCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "auctionEndPlusClaimTime",
          "type": "uint256"
        }
      ],
      "name": "hasUserSufficientFunds",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isInitialized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "auctionId",
          "type": "uint16"
        }
      ],
      "name": "settleAuction",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "auctionId",
          "type": "uint16"
        },
        {
          "internalType": "uint32",
          "name": "winningBidId",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "winningBidder",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "taker",
              "type": "address"
            },
            {
              "internalType": "uint16",
              "name": "paymentNonce",
              "type": "uint16"
            },
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "internalType": "struct AuctionPayout",
          "name": "payout",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "payoutSig",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "key",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "nextHash",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ConfidentialControl.UnlockArgs",
          "name": "uArgs",
          "type": "tuple"
        }
      ],
      "name": "settleAuctionCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "auctionId",
          "type": "uint16"
        }
      ],
      "name": "submitBid",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "auctionId",
          "type": "uint16"
        },
        {
          "internalType": "uint32",
          "name": "bidId",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "bidder",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "key",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "nextHash",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ConfidentialControl.UnlockArgs",
          "name": "uArgs",
          "type": "tuple"
        }
      ],
      "name": "submitBidCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "vault",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x92b8d06534a719fb26eb162ef37921861af37f113648de7435673120efbd123b",
  "receipt": {
    "to": null,
    "from": "0x16f2Aa8dF055b6e672b93Ded41FecCCabAB565B0",
    "contractAddress": "0x6075132C43BCb7792E475f3370c784295E42C30B",
    "transactionIndex": 0,
    "gasUsed": "9982668",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb34c2bce1895aaca13fc30a63a831f619a6463b6776d9212039798139161f61b",
    "transactionHash": "0x92b8d06534a719fb26eb162ef37921861af37f113648de7435673120efbd123b",
    "logs": [],
    "blockNumber": 971376,
    "cumulativeGasUsed": "9982668",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x2f4E4E7CFc9ebb9Ac8966529Ad30F753D98F4542",
    "https://ethereum-holesky-rpc.publicnode.com"
  ],
  "numDeployments": 1,
  "solcInputHash": "e40d5b9b28445f921bdb883098dd99ae",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_settlementChainRpc\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"PeekerReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"SuaveError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SuaveErrorWithData\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"auctioneer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hashedToken\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"until\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"payoutCollectionDuration\",\"type\":\"uint64\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"auctionId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"winningBidId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"paymentNonce\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct AuctionPayout\",\"name\":\"payout\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"payoutSig\",\"type\":\"bytes\"}],\"name\":\"AuctionSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"auctionId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"bidId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"BidPlaced\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"auctionMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"internalType\":\"enum AuctionStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"Suave.DataId\",\"name\":\"tokenDataId\",\"type\":\"bytes16\"},{\"internalType\":\"bytes32\",\"name\":\"hashedToken\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"bids\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"until\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"payoutCollectionDuration\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"auctioneer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ccontrolInit\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nextHash\",\"type\":\"bytes32\"},{\"internalType\":\"Suave.DataId\",\"name\":\"sBidId\",\"type\":\"bytes16\"}],\"name\":\"ccontrolInitCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ccontrolIsInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ccontrolOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"auctionId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"}],\"name\":\"checkBidValidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"auctionId\",\"type\":\"uint16\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confidentialConstructor\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Suave.DataId\",\"name\":\"_pkDataId\",\"type\":\"bytes16\"},{\"internalType\":\"Suave.DataId\",\"name\":\"_bidCountDataId\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"pkAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"ccontrolInitCallback\",\"type\":\"bytes\"}],\"name\":\"confidentialConstructorCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"auctionDuration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"payoutCollectionDuration\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"}],\"internalType\":\"struct NewAuctionArgs\",\"name\":\"auctionArgs\",\"type\":\"tuple\"}],\"name\":\"createAuction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"auctionDuration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"payoutCollectionDuration\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"}],\"internalType\":\"struct NewAuctionArgs\",\"name\":\"auctionArgs\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"tokenHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"auctioneer\",\"type\":\"address\"},{\"internalType\":\"Suave.DataId\",\"name\":\"tokenDataId\",\"type\":\"bytes16\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct ConfidentialControl.UnlockArgs\",\"name\":\"uArgs\",\"type\":\"tuple\"}],\"name\":\"createAuctionCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionEndPlusClaimTime\",\"type\":\"uint256\"}],\"name\":\"hasUserSufficientFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"auctionId\",\"type\":\"uint16\"}],\"name\":\"settleAuction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"auctionId\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"winningBidId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"winningBidder\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"paymentNonce\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct AuctionPayout\",\"name\":\"payout\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"payoutSig\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct ConfidentialControl.UnlockArgs\",\"name\":\"uArgs\",\"type\":\"tuple\"}],\"name\":\"settleAuctionCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"auctionId\",\"type\":\"uint16\"}],\"name\":\"submitBid\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"auctionId\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"bidId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct ConfidentialControl.UnlockArgs\",\"name\":\"uArgs\",\"type\":\"tuple\"}],\"name\":\"submitBidCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Auction.sol\":\"TokenAuction\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Auction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./AuctionOffchain.sol\\\";\\nimport \\\"./AuctionOnchain.sol\\\";\\n\\n// todo instead of timelock on the vault release the funds with a signature (MEVM checks funds are not used)\\n// todo: accounting systems that prevents users to use their funds multiple times accross different auctions\\n// todo: restrict access to callback methods\\n// todo: releasing funds only if user provides eip712 signature that specifies this (would prevent draining of funds if TEE pk is compromised) \\n// todo: the same account can just reuse their funds even with the same auction\\n\\ncontract TokenAuction is AuctionOnchain, AuctionOffchain {\\n    constructor(address _vault, string memory _settlementChainRpc) \\n        AuctionOnchain(_vault, _settlementChainRpc) {}\\n}\\n\",\"keccak256\":\"0x86c35945c529521d96cdc4edd8c0e0222ce6de749175538834da084d46d7ee50\",\"license\":\"MIT\"},\"contracts/AuctionCommon.sol\":{\"content\":\"import \\\"lib/suave-std/src/protocols/EthJsonRPC.sol\\\";\\nimport \\\"contracts/interface/ISettlementVault.sol\\\";\\nimport \\\"contracts/utils/AuctionUtils.sol\\\";\\nimport \\\"contracts/utils/ConfidentialControl.sol\\\";\\n\\nabstract contract AuctionCommon is ConfidentialControl {\\n    address public vault;\\n    address public auctionMaster;\\n    Auction[] public auctions;\\n\\n    bool public isInitialized;\\n    ISettlementVault vaultRemote;\\n    Suave.DataId internal pkDataId;\\n    Suave.DataId internal bidCountDataId;\\n\\n    modifier onlyInitialized() {\\n        require(isInitialized, \\\"Not initialized\\\");\\n        _;\\n    }\\n\\n}\\n\",\"keccak256\":\"0xec6d31fd353181ee37583de3a9a7a70da0b8f3e555605e5017b9c684ef9b64c3\"},\"contracts/AuctionOffchain.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n\\nimport \\\"lib/suave-std/src/suavelib/Suave.sol\\\";\\nimport \\\"lib/suave-std/src/Context.sol\\\";\\n\\nimport \\\"contracts/utils/SuaveContract.sol\\\";\\nimport \\\"contracts/utils/AuctionUtils.sol\\\";\\nimport \\\"contracts/utils/SigUtils.sol\\\";\\nimport \\\"./AuctionCommon.sol\\\";\\nimport \\\"./AuctionOnchain.sol\\\";\\n\\n\\ncontract AuctionOffchain is SuaveContract, AuctionCommon {\\n\\n    AuctionConfidentialStore immutable cstore = new AuctionConfidentialStore();\\n\\n    function confidentialConstructor() external returns (bytes memory) {\\n        crequire(!isInitialized, \\\"Already initialized\\\");\\n        string memory pk = Suave.privateKeyGen(Suave.CryptoSignature.SECP256);\\n        address pkAddress = getAddressForPk(pk);\\n        Suave.DataId _pkDataId = cstore.storePK(bytes(pk));\\n        Suave.DataId _bidCountDataId = cstore.storeBidCount(0);\\n\\n        bytes memory ccontrolInitCallback = ConfidentialControl.ccontrolInit();\\n        return\\n            abi.encodeWithSelector(\\n                AuctionOnchain.confidentialConstructorCallback.selector,\\n                _pkDataId,\\n                _bidCountDataId,\\n                pkAddress,\\n                ccontrolInitCallback\\n            );\\n    }\\n\\n    function createAuction(\\n        NewAuctionArgs memory auctionArgs\\n    ) external onlyConfidential onlyInitialized returns (bytes memory) {\\n        bytes memory tokenBytes = Context.confidentialInputs();\\n        bytes32 tokenHash = keccak256(tokenBytes);\\n        Suave.DataId tokenDataId = cstore.storeToken(tokenBytes);\\n        return\\n            abi.encodeWithSelector(\\n                AuctionOnchain.createAuctionCallback.selector,\\n                auctionArgs,\\n                tokenHash,\\n                msg.sender,\\n                tokenDataId,\\n                getUnlockPair()\\n            );\\n    }\\n\\n    function submitBid(\\n        uint16 auctionId\\n    ) external onlyConfidential onlyInitialized returns (bytes memory) {\\n        uint bidAmount = abi.decode(Context.confidentialInputs(), (uint));\\n        address bidder = msg.sender;\\n\\n        checkBidValidity(auctionId, bidder, bidAmount);\\n        uint32 bidId = BidUtils.getBidId(\\n            auctionId,\\n            incrementBidCount() \\n        );\\n        Bid memory bid = Bid(bidId, bidder, bidAmount);\\n        cstore.storeBid(bid, auctionId);\\n\\n        return\\n            abi.encodeWithSelector(\\n                AuctionOnchain.submitBidCallback.selector,\\n                auctionId,\\n                bidId,\\n                bidder,\\n                getUnlockPair()\\n            );\\n    }\\n\\n    function settleAuction(\\n        uint16 auctionId\\n    ) external onlyConfidential onlyInitialized returns (bytes memory) {\\n        Auction storage auction = auctions[auctionId];\\n        require(auction.status == AuctionStatus.LIVE, \\\"Auction is not live\\\");\\n        require(block.timestamp > auction.until, \\\"Auction has not ended\\\");\\n        require(auction.bids > 0, \\\"No bids\\\");\\n\\n        (Bid memory winningBid, uint scndBidAmount) = settleVickeryAuction(auctionId);\\n        AuctionPayout memory payout = AuctionPayout(\\n            vault,\\n            auction.payoutAddress,\\n            vaultRemote.accountToPaymentNonce(auction.payoutAddress),\\n            winningBid.bidder,\\n            scndBidAmount\\n        );\\n        bytes memory payoutSig = signPayout(payout);\\n\\n        return\\n            abi.encodeWithSelector(\\n                AuctionOnchain.settleAuctionCallback.selector,\\n                auctionId,\\n                winningBid.id,\\n                winningBid.bidder,\\n                payout,\\n                payoutSig,\\n                getUnlockPair()\\n            );\\n    }\\n\\n    function claimToken(uint16 auctionId) external onlyConfidential onlyInitialized {\\n        Auction storage auction = auctions[auctionId];\\n        require(auction.status == AuctionStatus.SETTLED, \\\"Auction is not settled\\\");\\n        require(auction.winner == msg.sender, \\\"Only winner can claim token\\\");\\n        // todo: instead of revert let the user pass encryption key\\n        revert(abi.decode(cstore.retrieveToken(auction.tokenDataId), (string)));\\n    }\\n\\n    function checkBidValidity(uint16 auctionId, address bidder, uint bidAmount) public {\\n        Auction storage auction = auctions[auctionId];\\n        require(auction.status == AuctionStatus.LIVE, \\\"Auction is not live\\\");\\n        require(block.timestamp <= auction.until, \\\"Auction has ended\\\");\\n        require(bidAmount > 0, \\\"Bid amount should be greater than zero\\\");\\n\\n        bool hasBidderFunds = hasUserSufficientFunds(\\n            bidder,\\n            bidAmount,\\n            auction.until + auction.payoutCollectionDuration\\n        );\\n        require(hasBidderFunds, \\\"Insufficient funds\\\");\\n    }\\n\\n    function hasUserSufficientFunds(\\n        address user,\\n        uint amount,\\n        uint auctionEndPlusClaimTime\\n    ) public returns (bool) {\\n        (uint balance, uint64 lockedUntil) = vaultRemote.getBalance(user);\\n        return balance >= amount && lockedUntil >= auctionEndPlusClaimTime;\\n    }\\n\\n    function signPayout(\\n        AuctionPayout memory payout\\n    ) internal returns (bytes memory sig) {\\n        string memory pk = cstore.retreivePK(pkDataId);\\n        bytes32 digest = keccak256(abi.encode(payout));\\n        sig = Suave.signMessage(\\n            abi.encodePacked(digest),\\n            Suave.CryptoSignature.SECP256,\\n            pk\\n        );\\n    }\\n\\n    function incrementBidCount() internal returns (uint16 bidCount) {\\n        bidCount = cstore.retrieveBidCount(bidCountDataId);\\n        cstore.updateBidCount(bidCountDataId, bidCount+1);\\n    }\\n\\n    function settleVickeryAuction(\\n        uint16 auctionId\\n    ) internal returns (Bid memory winningBid, uint scndBestBidAmount) {\\n        Bid[] memory bids = cstore.fetchBids(auctionId);\\n        (winningBid, scndBestBidAmount) = BidUtils.settleVickeryAuction(bids);\\n    }\\n\\n}\\n\\ncontract AuctionConfidentialStore {\\n    string constant PK_NAMESPACE = \\\"auction:v0:pksecret\\\";\\n    string constant BID_NAMESPACE = \\\"auction:v0:bids\\\";\\n    string constant BIDCOUNT_NAMESPACE = \\\"auction:v0:bidcount\\\";\\n    string constant TOKEN_NAMESPACE = \\\"auction:v0:token\\\";\\n\\n    address[] public genericPeekers = [\\n        0xC8df3686b4Afb2BB53e60EAe97EF043FE03Fb829\\n    ]; // todo: update after suave update (this exposes storage to everyone)\\n\\n\\n    function storeBid(Bid memory bid, uint16 auctionId) external {\\n        string memory namespace = string(abi.encodePacked(BID_NAMESPACE, auctionId));\\n        address[] memory peekers = new address[](3);\\n        peekers[0] = address(this);\\n        peekers[1] = Suave.FETCH_DATA_RECORDS;\\n        peekers[2] = Suave.CONFIDENTIAL_RETRIEVE;\\n        Suave.DataRecord memory secretBid = Suave.newDataRecord(\\n            0,\\n            genericPeekers,\\n            genericPeekers,\\n            namespace\\n        );\\n        Suave.confidentialStore(secretBid.id, namespace, abi.encode(bid));\\n    }\\n\\n    function fetchBids(uint16 auctionId) external returns (Bid[] memory) {\\n        string memory namespace = string(abi.encodePacked(BID_NAMESPACE, auctionId));\\n        Suave.DataRecord[] memory dataRecords = Suave.fetchDataRecords(\\n            0,\\n            namespace\\n        );\\n        Bid[] memory bids = new Bid[](dataRecords.length);\\n        for (uint i = 0; i < dataRecords.length; i++) {\\n            bytes memory bidBytes = Suave.confidentialRetrieve(\\n                dataRecords[i].id,\\n                namespace\\n            );\\n            Bid memory bid = abi.decode(bidBytes, (Bid));\\n            bids[i] = bid;\\n        }\\n        return bids;\\n    }\\n\\n    function storeBidCount(uint16 bidCount) external returns (Suave.DataId) {\\n        address[] memory peekers = new address[](3);\\n        peekers[0] = address(this);\\n        peekers[1] = Suave.FETCH_DATA_RECORDS;\\n        peekers[2] = Suave.CONFIDENTIAL_RETRIEVE;\\n        \\n        Suave.DataRecord memory dataRec = Suave.newDataRecord(\\n            0,\\n            peekers,\\n            peekers,\\n            BIDCOUNT_NAMESPACE\\n        );\\n        Suave.confidentialStore(dataRec.id, BIDCOUNT_NAMESPACE, abi.encode(bidCount));\\n        return dataRec.id;\\n    }\\n\\n    function updateBidCount(Suave.DataId bidCountDataId, uint16 bidCount) external {\\n        Suave.confidentialStore(bidCountDataId, BIDCOUNT_NAMESPACE, abi.encode(bidCount));\\n    }\\n\\n    function retrieveBidCount(Suave.DataId bidCountDataId) public returns (uint16) {\\n        bytes memory bidCountBytes = Suave.confidentialRetrieve(\\n            bidCountDataId,\\n            BIDCOUNT_NAMESPACE\\n        );\\n        return abi.decode(bidCountBytes, (uint16));\\n    }\\n\\n    function storeToken(bytes memory tokenBytes) external returns (Suave.DataId) {\\n        address[] memory peekers = new address[](3);\\n        peekers[0] = address(this);\\n        peekers[1] = Suave.FETCH_DATA_RECORDS;\\n        peekers[2] = Suave.CONFIDENTIAL_RETRIEVE;\\n        Suave.DataRecord memory secretBid = Suave.newDataRecord(\\n            0,\\n            genericPeekers,\\n            genericPeekers,\\n            TOKEN_NAMESPACE\\n        );\\n        Suave.confidentialStore(secretBid.id, TOKEN_NAMESPACE, tokenBytes);\\n        return secretBid.id;\\n    }\\n\\n    function retrieveToken(Suave.DataId tokenDataId) external returns (bytes memory tokenBytes) {\\n        tokenBytes = Suave.confidentialRetrieve(tokenDataId, TOKEN_NAMESPACE);\\n    }\\n\\n    function storePK(bytes memory pk) external returns (Suave.DataId) {\\n        address[] memory peekers = new address[](3);\\n        peekers[0] = address(this);\\n        peekers[1] = Suave.FETCH_DATA_RECORDS;\\n        peekers[2] = Suave.CONFIDENTIAL_RETRIEVE;\\n        Suave.DataRecord memory secretBid = Suave.newDataRecord(\\n            0,\\n            genericPeekers,\\n            genericPeekers,\\n            PK_NAMESPACE\\n        );\\n        Suave.confidentialStore(secretBid.id, PK_NAMESPACE, pk);\\n        return secretBid.id;\\n    }\\n\\n    function retreivePK(Suave.DataId pkDataId) external returns (string memory) {\\n        bytes memory pkBytes = Suave.confidentialRetrieve(\\n            pkDataId,\\n            PK_NAMESPACE\\n        );\\n        return string(pkBytes);\\n    }\\n\\n}\",\"keccak256\":\"0x1120b7019407685c9219a689b0d35a30dd0841545af0f256939ffd7075cde56e\",\"license\":\"MIT\"},\"contracts/AuctionOnchain.sol\":{\"content\":\"// import \\\"contracts/utils/AuctionUtils.sol\\\";\\nimport { Suave } from \\\"lib/suave-std/src/suavelib/Suave.sol\\\";\\nimport \\\"lib/suave-std/src/Gateway.sol\\\";\\nimport \\\"./AuctionCommon.sol\\\";\\n\\n\\ncontract AuctionOnchain is AuctionCommon {\\n    event AuctionCreated(\\n        uint256 indexed auctionId,\\n        address indexed auctioneer,\\n        bytes32 indexed hashedToken,\\n        address payoutAddress,\\n        uint64 until,\\n        uint64 payoutCollectionDuration\\n    );\\n    event AuctionCancelled(uint indexed auctionId);\\n    event AuctionSettled(\\n        uint16 indexed auctionId,\\n        uint32 winningBidId,\\n        AuctionPayout payout,\\n        bytes payoutSig\\n    );\\n    event BidPlaced(\\n        uint16 indexed auctionId,\\n        uint32 indexed bidId,\\n        address indexed bidder\\n    );\\n\\n    constructor(address _vault, string memory _settlementChainRpc) {\\n        vault = _vault;\\n        address gateway = address(new Gateway(_settlementChainRpc, _vault));\\n        vaultRemote = ISettlementVault(gateway);\\n    }\\n\\n    function confidentialConstructorCallback(\\n        Suave.DataId _pkDataId,\\n        Suave.DataId _bidCountDataId,\\n        address pkAddress, \\n        bytes memory ccontrolInitCallback\\n    ) public onlyOwner {\\n        require(!isInitialized, \\\"Already initialized\\\");\\n        bidCountDataId = _bidCountDataId;\\n        pkDataId = _pkDataId;\\n        auctionMaster = pkAddress;\\n        isInitialized = true;\\n        \\n        (bool s,) = address(this).delegatecall(ccontrolInitCallback);\\n        require(s, \\\"Initialization of ConfidentialControl failed\\\");\\n    }\\n\\n    function createAuctionCallback(\\n        NewAuctionArgs memory auctionArgs,\\n        bytes32 tokenHash,\\n        address auctioneer, \\n        Suave.DataId tokenDataId,\\n        UnlockArgs calldata uArgs\\n    ) external unlock(uArgs) {\\n        uint64 until = uint64(block.timestamp) + auctionArgs.auctionDuration;\\n        Auction storage newAuction = auctions.push();\\n        newAuction.status = AuctionStatus.LIVE;\\n        newAuction.payoutAddress = auctionArgs.payoutAddress;\\n        newAuction.hashedToken = tokenHash;\\n        newAuction.until = until;\\n        newAuction.payoutCollectionDuration = auctionArgs\\n            .payoutCollectionDuration;\\n        newAuction.auctioneer = auctioneer;\\n        newAuction.tokenDataId = tokenDataId;\\n\\n        emit AuctionCreated(\\n            auctions.length - 1,\\n            auctioneer,\\n            tokenHash,\\n            auctionArgs.payoutAddress,\\n            until,\\n            auctionArgs.payoutCollectionDuration\\n        );\\n    }\\n\\n    function submitBidCallback(\\n        uint16 auctionId,\\n        uint32 bidId,\\n        address bidder,\\n        UnlockArgs calldata uArgs\\n    ) external unlock(uArgs) {\\n        auctions[auctionId].bids++;\\n        emit BidPlaced(auctionId, bidId, bidder);\\n    }\\n\\n    function settleAuctionCallback(\\n        uint16 auctionId,\\n        uint32 winningBidId,\\n        address winningBidder,\\n        AuctionPayout memory payout,\\n        bytes memory payoutSig,\\n        UnlockArgs calldata uArgs\\n    ) external unlock(uArgs) {\\n        Auction storage auction = auctions[auctionId];\\n        auction.status = AuctionStatus.SETTLED;\\n        auction.winner = winningBidder;\\n        emit AuctionSettled(auctionId, winningBidId, payout, payoutSig);\\n    }\\n\\n    function cancelAuction(uint256 auctionId) external {\\n        Auction storage auction = auctions[auctionId];\\n        require(auction.auctioneer == msg.sender, \\\"Only auction master can cancel\\\");\\n        require(auction.status == AuctionStatus.LIVE, \\\"Auction is not live\\\");\\n        auctions[auctionId].status = AuctionStatus.CANCELLED;\\n        emit AuctionCancelled(auctionId);\\n    }\\n\\n    fallback() external {}\\n\\n}\\n\",\"keccak256\":\"0xc776dd568cad7aa6c85943646467868f87340be1a93f9ff8fc197080f04db70e\"},\"contracts/interface/ISettlementVault.sol\":{\"content\":\"\\n\\n\\ninterface ISettlementVault {\\n    function getBalance(address user) external returns (uint, uint64);\\n    function accountToPaymentNonce(address account) external returns (uint16);\\n}\",\"keccak256\":\"0x2ab73acd83a9bc95ff6fd85d22de58b4c0354190e618031166a79cfb426aa427\"},\"contracts/utils/AuctionUtils.sol\":{\"content\":\"pragma solidity ^0.8.8;\\n\\nimport { Suave } from \\\"lib/suave-std/src/suavelib/Suave.sol\\\";\\n\\nenum AuctionStatus {\\n    LIVE,\\n    CANCELLED,\\n    SETTLED\\n}\\n\\nstruct Auction {\\n    address payoutAddress;\\n    AuctionStatus status;\\n    Suave.DataId tokenDataId;\\n    bytes32 hashedToken;\\n    uint32 bids;\\n    uint64 until;\\n    uint64 payoutCollectionDuration;\\n    address auctioneer;\\n    address winner;\\n}\\nstruct Bid {\\n    uint32 id;\\n    address bidder;\\n    uint256 amount;\\n}\\nstruct NewAuctionArgs {\\n    uint64 auctionDuration;\\n    uint64 payoutCollectionDuration;\\n    address payoutAddress;\\n}\\nstruct AuctionPayout {\\n    address vault;\\n    address taker;\\n    uint16 paymentNonce;\\n    address account;\\n    uint amount;\\n}\\n\\nlibrary BidUtils {\\n\\n    function getBidId(uint16 auctionId, uint16 bidIndex) internal pure returns (uint32) {\\n        return uint32(auctionId << 16 | bidIndex);\\n    }\\n\\n    function unpackBidId(uint32 bidId) internal pure returns (uint16 auctionId, uint16 bidIndex) {\\n        auctionId = uint16(bidId >> 16);\\n        bidIndex = uint16(bidId);\\n    }\\n\\n    function settleVickeryAuction(\\n        Bid[] memory bids\\n    ) internal pure returns (Bid memory winningBid, uint scndBestBidAmount) {\\n        for (uint i = 0; i < bids.length; ++i) {\\n            Bid memory bid = bids[i];\\n            if (bid.amount > winningBid.amount) {\\n                scndBestBidAmount = winningBid.amount;\\n                winningBid = bid;\\n            } else if (bid.amount > scndBestBidAmount) {\\n                scndBestBidAmount = bid.amount;\\n            }\\n        }\\n        if (scndBestBidAmount == 0) {\\n            scndBestBidAmount = winningBid.amount;\\n        }\\n    }\\n\\n}\",\"keccak256\":\"0x463540a6737cc70d974078bb53253b749e1ba680504ea4f96c854f308a404851\"},\"contracts/utils/ConfidentialControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Author: Miha Lotric (halo3mic)\\n\\n\\npragma solidity ^0.8.8;\\n\\nimport { SuaveContract, Suave } from \\\"./SuaveContract.sol\\\";\\n\\n\\nabstract contract ConfidentialControl is SuaveContract {\\n\\tstruct UnlockArgs {\\n\\t\\tbytes32 key;\\n\\t\\tbytes32 nextHash;\\n\\t}\\n\\n\\tmodifier unlock(UnlockArgs calldata unlockPair) {\\n\\t\\tcrequire(isValidKey(unlockPair.key), \\\"Invalid key\\\");\\n\\t\\t_;\\n\\t\\tpresentHash = unlockPair.nextHash;\\n\\t\\tnonce++;\\n\\t}\\n\\n\\tmodifier onlyOwner() {\\n\\t\\tcrequire(msg.sender == ccontrolOwner, \\\"Unauthorized\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\taddress public immutable ccontrolOwner = msg.sender;\\n\\tstring internal constant S_NAMESPACE = \\\"blockad:v0:secret\\\";\\n\\tSuave.DataId internal secretBidId;\\n\\tbytes32 internal presentHash;\\n\\tuint internal nonce;\\n\\n\\tfunction ccontrolInitCallback(\\n        bytes32 nextHash, \\n        Suave.DataId sBidId\\n    ) external onlyOwner {\\n\\t\\tpresentHash = nextHash;\\n\\t\\tsecretBidId = sBidId;\\n\\t}\\n\\n\\tfunction ccontrolIsInitialized() public view returns (bool) {\\n\\t\\treturn presentHash != 0;\\n\\t}\\n\\n\\tfunction ccontrolInit() public onlyOwner returns (bytes memory) {\\n\\t\\tbytes memory secret = Suave.randomBytes(32);\\n\\t\\tSuave.DataId sBidId = storeSecret(secret);\\n\\t\\tbytes32 nextHash = makeHash(abi.decode(secret, (bytes32)), nonce);\\n\\t\\treturn abi.encodeWithSelector(this.ccontrolInitCallback.selector, nextHash, sBidId);\\n\\t}\\n\\n\\tfunction getUnlockPair() internal returns (UnlockArgs memory) {\\n\\t\\treturn UnlockArgs(getKey(nonce), getHash(nonce + 1));\\n\\t}\\n\\n\\tfunction storeSecret(bytes memory secret) internal returns (Suave.DataId) {\\n\\t\\taddress[] memory peekers = new address[](3);\\n\\t\\tpeekers[0] = address(this);\\n\\t\\tpeekers[1] = Suave.FETCH_DATA_RECORDS;\\n\\t\\tpeekers[2] = Suave.CONFIDENTIAL_RETRIEVE;\\n\\t\\tSuave.DataRecord memory secretBid = Suave.newDataRecord(0, peekers, peekers, S_NAMESPACE);\\n\\t\\tSuave.confidentialStore(secretBid.id, S_NAMESPACE, secret);\\n\\t\\treturn secretBid.id;\\n\\t}\\n\\n\\tfunction isValidKey(bytes32 key) internal view returns (bool) {\\n\\t\\treturn keccak256(abi.encode(key)) == presentHash;\\n\\t}\\n\\n\\tfunction getHash(uint _nonce) internal returns (bytes32) {\\n\\t\\treturn keccak256(abi.encode(getKey(_nonce)));\\n\\t}\\n\\n\\tfunction getKey(uint _nonce) internal returns (bytes32) {\\n\\t\\treturn makeKey(getSecret(), _nonce);\\n\\t}\\n\\n\\tfunction makeHash(bytes32 secret, uint _nonce) internal pure returns (bytes32) {\\n\\t\\treturn keccak256(abi.encode(makeKey(secret, _nonce)));\\n\\t}\\n\\n\\tfunction makeKey(bytes32 secret, uint _nonce) internal pure returns (bytes32) {\\n\\t\\treturn keccak256(abi.encode(secret, _nonce));\\n\\t}\\n\\n\\tfunction getSecret() internal returns (bytes32) {\\n\\t\\tbytes memory secretB = Suave.confidentialRetrieve(secretBidId, S_NAMESPACE);\\n\\t\\treturn abi.decode(secretB, (bytes32));\\n\\t}\\n}\\n\",\"keccak256\":\"0xe6f6ede75ce2c3e5a2835fe12deacbd5263bf1521e86e174bd1cf6b5ad5d8294\",\"license\":\"MIT\"},\"contracts/utils/SigUtils.sol\":{\"content\":\"pragma solidity ^0.8.8;\\n\\nimport { Suave } from \\\"lib/suave-std/src/suavelib/Suave.sol\\\";\\n\\n\\nfunction getAddressForPk(string memory pk) returns (address) {\\n    bytes32 digest = keccak256(abi.encode(\\\"yo\\\"));\\n    bytes memory sig = Suave.signMessage(abi.encodePacked(digest), Suave.CryptoSignature.SECP256, pk);\\n    return recoverSigner(digest, sig);\\n}\\n\\nfunction recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) pure returns (address) {\\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n    return ecrecover(_ethSignedMessageHash, v, r, s);\\n}\\n\\nfunction splitSignature(bytes memory sig) pure returns (bytes32 r, bytes32 s, uint8 v) {\\n    require(sig.length == 65, \\\"invalid signature length\\\");\\n    assembly {\\n        r := mload(add(sig, 32))\\n        s := mload(add(sig, 64))\\n        v := byte(0, mload(add(sig, 96)))\\n    }\\n    if (v < 27) {\\n        v += 27;\\n    }\\n}\",\"keccak256\":\"0x5c6b676b686f0b095f1eea08dd7c53ecbd77604913ca9d70c916b223a08775bb\"},\"contracts/utils/SuaveContract.sol\":{\"content\":\"pragma solidity ^0.8.9;\\n\\nimport { Suave } from \\\"lib/suave-std/src/suavelib/Suave.sol\\\";\\n\\n\\nabstract contract SuaveContract {\\n\\terror SuaveError(string message);\\n\\terror SuaveErrorWithData(string message, bytes data);\\n\\n\\tmodifier onlyConfidential() {\\n\\t\\tcrequire(Suave.isConfidential(), \\\"Not confidential\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tfunction crequire(bool condition, string memory message) internal pure {\\n\\t\\tif (!condition) {\\n\\t\\t\\trevert SuaveError(message);\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x353a9ad3173741537d72629211b8a3dda54b01fd9f7429f3221ace6463419948\"},\"forge-std/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _castLogPayloadViewToPure(\\n        function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\\n    }\\n\\n    function _sendLogPayloadView(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(int p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint p0, uint p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, int p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,int)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n}\\n\",\"keccak256\":\"0xf61cb43a94d8318049d0a7f567af8c0aa952b5762a43851b130b90b3fcde0c6a\",\"license\":\"MIT\"},\"lib/suave-std/src/Context.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"./suavelib/Suave.sol\\\";\\n\\n/// @notice Context is a library with functions to retrieve the context of the MEVM execution.\\nlibrary Context {\\n    /// @notice returns the confidential inputs of the confidential compute request.\\n    /// @return output bytes of the confidential inputs.\\n    function confidentialInputs() internal returns (bytes memory) {\\n        return Suave.contextGet(\\\"confidentialInputs\\\");\\n    }\\n\\n    /// @notice returns the address of the Kettle that executes the confidential compute request.\\n    /// @return kettleAddress address of the kettle.\\n    function kettleAddress() internal returns (address) {\\n        bytes memory _bytes = Suave.contextGet(\\\"kettleAddress\\\");\\n\\n        address addr;\\n        assembly {\\n            addr := mload(add(_bytes, 20))\\n        }\\n\\n        return addr;\\n    }\\n}\\n\",\"keccak256\":\"0xb49e71ba6008985de578720a6a5deac2886594bba21aff55eac1d74a25c263a7\",\"license\":\"Unlicense\"},\"lib/suave-std/src/Gateway.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.8;\\n\\nimport \\\"./protocols/EthJsonRPC.sol\\\";\\nimport \\\"forge-std/console.sol\\\";\\n\\ncontract Gateway {\\n    EthJsonRPC ethjsonrpc;\\n    address target;\\n\\n    constructor(string memory _jsonrpc, address _target) {\\n        ethjsonrpc = new EthJsonRPC(_jsonrpc);\\n        target = _target;\\n    }\\n\\n    fallback() external {\\n        bytes memory ret = ethjsonrpc.call(target, msg.data);\\n\\n        assembly {\\n            let location := ret\\n            let length := mload(ret)\\n            return(add(location, 0x20), length)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd4ba77532489ea7e4d33e315f784c1c2d9b894ff16c7c6ae86429c21af5b07af\",\"license\":\"UNLICENSED\"},\"lib/suave-std/src/protocols/EthJsonRPC.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"../suavelib/Suave.sol\\\";\\nimport \\\"solady/src/utils/JSONParserLib.sol\\\";\\nimport \\\"solady/src/utils/LibString.sol\\\";\\nimport \\\"forge-std/console.sol\\\";\\nimport \\\"../utils/HexStrings.sol\\\";\\n\\n/// @notice EthJsonRPC is a library with utilities to interact with an Ethereum JSON-RPC endpoint.\\ncontract EthJsonRPC {\\n    using JSONParserLib for *;\\n\\n    string endpoint;\\n\\n    struct AccountOverride {\\n        address addr;\\n        bytes code;\\n    }\\n\\n    constructor(string memory _endpoint) {\\n        endpoint = _endpoint;\\n    }\\n\\n    /// @notice get the nonce of an address.\\n    /// @param addr the address to get the nonce.\\n    /// @return val the nonce of the address.\\n    function nonce(address addr) public returns (uint256) {\\n        bytes memory body = abi.encodePacked(\\n            '{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_getTransactionCount\\\",\\\"params\\\":[\\\"',\\n            LibString.toHexStringChecksummed(addr),\\n            '\\\",\\\"latest\\\"],\\\"id\\\":1}'\\n        );\\n\\n        JSONParserLib.Item memory item = doRequest(string(body));\\n        uint256 val = JSONParserLib.parseUintFromHex(trimQuotes(item.value()));\\n        return val;\\n    }\\n\\n    /// @notice get the balance of an address.\\n    /// @param addr the address to get the balance.\\n    /// @return val the balance of the address.\\n    function balance(address addr) public returns (uint256) {\\n        bytes memory body = abi.encodePacked(\\n            '{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_getBalance\\\",\\\"params\\\":[\\\"',\\n            LibString.toHexStringChecksummed(addr),\\n            '\\\",\\\"latest\\\"],\\\"id\\\":1}'\\n        );\\n\\n        JSONParserLib.Item memory item = doRequest(string(body));\\n        uint256 val = JSONParserLib.parseUintFromHex(trimQuotes(item.value()));\\n        return val;\\n    }\\n\\n    /// @notice call a contract function.\\n    /// @param to the address of the contract.\\n    /// @param data the data of the function.\\n    /// @return the result of the function call.\\n    function call(address to, bytes memory data) public returns (bytes memory) {\\n        bytes memory body = abi.encodePacked(\\n            '{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_call\\\",\\\"params\\\":[{\\\"to\\\":\\\"',\\n            LibString.toHexStringChecksummed(to),\\n            '\\\",\\\"data\\\":\\\"',\\n            LibString.toHexString(data),\\n            '\\\"},\\\"latest\\\"],\\\"id\\\":1}'\\n        );\\n\\n        JSONParserLib.Item memory item = doRequest(string(body));\\n        bytes memory result = HexStrings.fromHexString(_stripQuotesAndPrefix(item.value()));\\n        return result;\\n    }\\n\\n    /// @notice call a contract function with a state override.\\n    /// @param to the address of the contract.\\n    /// @param data the data of the function.\\n    /// @param accountOverride the state override.\\n    /// @return the result of the function call.\\n    function call(address to, bytes memory data, AccountOverride[] memory accountOverride)\\n        public\\n        returns (bytes memory)\\n    {\\n        bytes memory body = abi.encodePacked(\\n            '{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_call\\\",\\\"params\\\":[{\\\"to\\\":\\\"',\\n            LibString.toHexStringChecksummed(to),\\n            '\\\",\\\"data\\\":\\\"',\\n            LibString.toHexString(data),\\n            '\\\"},\\\"latest\\\",{'\\n        );\\n\\n        for (uint256 i = 0; i < accountOverride.length; i++) {\\n            body = abi.encodePacked(\\n                body,\\n                '\\\"',\\n                LibString.toHexStringChecksummed(accountOverride[i].addr),\\n                '\\\": {\\\"code\\\": \\\"',\\n                LibString.toHexString(accountOverride[i].code),\\n                '\\\"}'\\n            );\\n            if (i < accountOverride.length - 1) {\\n                body = abi.encodePacked(body, \\\",\\\");\\n            }\\n        }\\n        body = abi.encodePacked(body, '}],\\\"id\\\":1}');\\n\\n        JSONParserLib.Item memory item = doRequest(string(body));\\n        bytes memory result = HexStrings.fromHexString(_stripQuotesAndPrefix(item.value()));\\n\\n        return result;\\n    }\\n\\n    function doRequest(string memory body) public returns (JSONParserLib.Item memory) {\\n        Suave.HttpRequest memory request;\\n        request.method = \\\"POST\\\";\\n        request.url = endpoint;\\n        request.headers = new string[](1);\\n        request.headers[0] = \\\"Content-Type: application/json\\\";\\n        request.body = bytes(body);\\n\\n        bytes memory output = Suave.doHTTPRequest(request);\\n\\n        JSONParserLib.Item memory item = string(output).parse();\\n        JSONParserLib.Item memory err = item.at('\\\"error\\\"');\\n        if (!err.isUndefined()) {\\n            revert(err.value());\\n        }\\n        return item.at('\\\"result\\\"');\\n    }\\n\\n    function _stripQuotesAndPrefix(string memory s) internal pure returns (string memory) {\\n        bytes memory strBytes = bytes(s);\\n        bytes memory result = new bytes(strBytes.length - 4);\\n        for (uint256 i = 3; i < strBytes.length - 1; i++) {\\n            result[i - 3] = strBytes[i];\\n        }\\n        return string(result);\\n    }\\n\\n    function trimQuotes(string memory input) private pure returns (string memory) {\\n        bytes memory inputBytes = bytes(input);\\n        require(\\n            inputBytes.length >= 2 && inputBytes[0] == '\\\"' && inputBytes[inputBytes.length - 1] == '\\\"', \\\"Invalid input\\\"\\n        );\\n\\n        bytes memory result = new bytes(inputBytes.length - 2);\\n\\n        for (uint256 i = 1; i < inputBytes.length - 1; i++) {\\n            result[i - 1] = inputBytes[i];\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\",\"keccak256\":\"0xa553102e760f848c1e2800a8cc129b28cad7a00e30689da00ccb28a79a3a3a70\",\"license\":\"Unlicense\"},\"lib/suave-std/src/suavelib/Suave.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.8;\\n\\n/// @notice Library to interact with the Suave MEVM precompiles.\\nlibrary Suave {\\n    error PeekerReverted(address, bytes);\\n\\n    enum CryptoSignature {\\n        SECP256,\\n        BLS\\n    }\\n\\n    type DataId is bytes16;\\n\\n    /// @notice Arguments to build the block.\\n    /// @param slot Slot number of the block\\n    /// @param proposerPubkey Public key of the proposer\\n    /// @param parent Hash of the parent block\\n    /// @param timestamp Timestamp of the block\\n    /// @param feeRecipient Address of the fee recipient\\n    /// @param gasLimit Gas limit of the block\\n    /// @param random Randomness of the block\\n    /// @param withdrawals List of withdrawals\\n    /// @param extra Extra data of the block\\n    /// @param beaconRoot Root of the beacon chain\\n    /// @param fillPending Whether to fill the block with pending transactions\\n    struct BuildBlockArgs {\\n        uint64 slot;\\n        bytes proposerPubkey;\\n        bytes32 parent;\\n        uint64 timestamp;\\n        address feeRecipient;\\n        uint64 gasLimit;\\n        bytes32 random;\\n        Withdrawal[] withdrawals;\\n        bytes extra;\\n        bytes32 beaconRoot;\\n        bool fillPending;\\n    }\\n\\n    /// @notice A record of data stored in the ConfidentialStore.\\n    /// @param id ID of the data record\\n    /// @param salt Salt used to derive the encryption key\\n    /// @param decryptionCondition Up to which block this data record is valid\\n    /// @param allowedPeekers Addresses which can get data\\n    /// @param allowedStores Addresses can set data\\n    /// @param version Namespace of the data record\\n    struct DataRecord {\\n        DataId id;\\n        DataId salt;\\n        uint64 decryptionCondition;\\n        address[] allowedPeekers;\\n        address[] allowedStores;\\n        string version;\\n    }\\n\\n    /// @notice Description of an HTTP request.\\n    /// @param url Target url of the request\\n    /// @param method HTTP method of the request\\n    /// @param headers HTTP Headers\\n    /// @param body Body of the request (if Post or Put)\\n    /// @param withFlashbotsSignature Whether to include the Flashbots signature\\n    /// @param timeout Timeout of the request in milliseconds\\n    struct HttpRequest {\\n        string url;\\n        string method;\\n        string[] headers;\\n        bytes body;\\n        bool withFlashbotsSignature;\\n        uint64 timeout;\\n    }\\n\\n    /// @notice Result of a simulated transaction.\\n    /// @param egp Effective Gas Price of the transaction\\n    /// @param logs Logs emitted during the simulation\\n    /// @param success Whether the transaction was successful or not\\n    /// @param error Error message if any\\n    struct SimulateTransactionResult {\\n        uint64 egp;\\n        SimulatedLog[] logs;\\n        bool success;\\n        string error;\\n    }\\n\\n    /// @notice A log emitted during the simulation of a transaction.\\n    /// @param data Data of the log\\n    /// @param addr Address of the contract that emitted the log\\n    /// @param topics Topics of the log\\n    struct SimulatedLog {\\n        bytes data;\\n        address addr;\\n        bytes32[] topics;\\n    }\\n\\n    /// @notice A withdrawal from the beacon chain.\\n    /// @param index Index of the withdrawal\\n    /// @param validator ID of the validator\\n    /// @param Address Address to withdraw to\\n    /// @param amount Amount to be withdrawn\\n    struct Withdrawal {\\n        uint64 index;\\n        uint64 validator;\\n        address Address;\\n        uint64 amount;\\n    }\\n\\n    address public constant ANYALLOWED = 0xC8df3686b4Afb2BB53e60EAe97EF043FE03Fb829;\\n\\n    address public constant IS_CONFIDENTIAL_ADDR = 0x0000000000000000000000000000000042010000;\\n\\n    address public constant BUILD_ETH_BLOCK = 0x0000000000000000000000000000000042100001;\\n\\n    address public constant BUILD_ETH_BLOCK_TO = 0x0000000000000000000000000000000042100006;\\n\\n    address public constant CONFIDENTIAL_INPUTS = 0x0000000000000000000000000000000042010001;\\n\\n    address public constant CONFIDENTIAL_RETRIEVE = 0x0000000000000000000000000000000042020001;\\n\\n    address public constant CONFIDENTIAL_STORE = 0x0000000000000000000000000000000042020000;\\n\\n    address public constant CONTEXT_GET = 0x0000000000000000000000000000000053300003;\\n\\n    address public constant DO_HTTPREQUEST = 0x0000000000000000000000000000000043200002;\\n\\n    address public constant ETHCALL = 0x0000000000000000000000000000000042100003;\\n\\n    address public constant EXTRACT_HINT = 0x0000000000000000000000000000000042100037;\\n\\n    address public constant FETCH_DATA_RECORDS = 0x0000000000000000000000000000000042030001;\\n\\n    address public constant FILL_MEV_SHARE_BUNDLE = 0x0000000000000000000000000000000043200001;\\n\\n    address public constant NEW_BUILDER = 0x0000000000000000000000000000000053200001;\\n\\n    address public constant NEW_DATA_RECORD = 0x0000000000000000000000000000000042030000;\\n\\n    address public constant PRIVATE_KEY_GEN = 0x0000000000000000000000000000000053200003;\\n\\n    address public constant RANDOM_BYTES = 0x000000000000000000000000000000007770000b;\\n\\n    address public constant SIGN_ETH_TRANSACTION = 0x0000000000000000000000000000000040100001;\\n\\n    address public constant SIGN_MESSAGE = 0x0000000000000000000000000000000040100003;\\n\\n    address public constant SIMULATE_BUNDLE = 0x0000000000000000000000000000000042100000;\\n\\n    address public constant SIMULATE_TRANSACTION = 0x0000000000000000000000000000000053200002;\\n\\n    address public constant SUBMIT_BUNDLE_JSON_RPC = 0x0000000000000000000000000000000043000001;\\n\\n    address public constant SUBMIT_ETH_BLOCK_TO_RELAY = 0x0000000000000000000000000000000042100002;\\n\\n    /// @notice Returns whether execution is off- or on-chain\\n    /// @return b Whether execution is off- or on-chain\\n    function isConfidential() internal returns (bool b) {\\n        (bool success, bytes memory isConfidentialBytes) = IS_CONFIDENTIAL_ADDR.call(\\\"\\\");\\n        if (!success) {\\n            revert PeekerReverted(IS_CONFIDENTIAL_ADDR, isConfidentialBytes);\\n        }\\n        assembly {\\n            // Load the length of data (first 32 bytes)\\n            let len := mload(isConfidentialBytes)\\n            // Load the data after 32 bytes, so add 0x20\\n            b := mload(add(isConfidentialBytes, 0x20))\\n        }\\n    }\\n\\n    /// @notice Constructs an Ethereum block based on the provided data records. No blobs are returned.\\n    /// @param blockArgs Arguments to build the block\\n    /// @param dataId ID of the data record with mev-share bundle data\\n    /// @param relayUrl If specified the built block will be submitted to the relay\\n    /// @return blockBid Block Bid encoded in JSON\\n    /// @return executionPayload Execution payload encoded in JSON\\n    function buildEthBlock(BuildBlockArgs memory blockArgs, DataId dataId, string memory relayUrl)\\n        internal\\n        returns (bytes memory, bytes memory)\\n    {\\n        (bool success, bytes memory data) = BUILD_ETH_BLOCK.call(abi.encode(blockArgs, dataId, relayUrl));\\n        if (!success) {\\n            revert PeekerReverted(BUILD_ETH_BLOCK, data);\\n        }\\n\\n        return abi.decode(data, (bytes, bytes));\\n    }\\n\\n    /// @notice Constructs an Ethereum block based on the provided data records. No blobs are returned.\\n    /// @param executionNodeURL URL (or service name) of the execution node\\n    /// @param blockArgs Arguments to build the block\\n    /// @param dataId ID of the data record with mev-share bundle data\\n    /// @param relayUrl If specified the built block will be submitted to the relay\\n    /// @return blockBid Block Bid encoded in JSON\\n    /// @return executionPayload Execution payload encoded in JSON\\n    function buildEthBlockTo(\\n        string memory executionNodeURL,\\n        BuildBlockArgs memory blockArgs,\\n        DataId dataId,\\n        string memory relayUrl\\n    ) internal returns (bytes memory, bytes memory) {\\n        (bool success, bytes memory data) =\\n            BUILD_ETH_BLOCK_TO.call(abi.encode(executionNodeURL, blockArgs, dataId, relayUrl));\\n        if (!success) {\\n            revert PeekerReverted(BUILD_ETH_BLOCK_TO, data);\\n        }\\n\\n        return abi.decode(data, (bytes, bytes));\\n    }\\n\\n    /// @notice Provides the confidential inputs associated with a confidential computation request. Outputs are in bytes format.\\n    /// @return confindentialData Confidential inputs\\n    function confidentialInputs() internal returns (bytes memory) {\\n        (bool success, bytes memory data) = CONFIDENTIAL_INPUTS.call(abi.encode());\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_INPUTS, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Retrieves data from the confidential store. Also mandates the caller's presence in the `AllowedPeekers` list.\\n    /// @param dataId ID of the data record to retrieve\\n    /// @param key Key slot of the data to retrieve\\n    /// @return value Value of the data\\n    function confidentialRetrieve(DataId dataId, string memory key) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = CONFIDENTIAL_RETRIEVE.call(abi.encode(dataId, key));\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_RETRIEVE, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Stores data in the confidential store. Requires the caller to be part of the `AllowedPeekers` for the associated data record.\\n    /// @param dataId ID of the data record to store\\n    /// @param key Key slot of the data to store\\n    /// @param value Value of the data to store\\n    function confidentialStore(DataId dataId, string memory key, bytes memory value) internal {\\n        (bool success, bytes memory data) = CONFIDENTIAL_STORE.call(abi.encode(dataId, key, value));\\n        if (!success) {\\n            revert PeekerReverted(CONFIDENTIAL_STORE, data);\\n        }\\n    }\\n\\n    /// @notice Retrieves a value from the context\\n    /// @param key Key of the value to retrieve\\n    /// @return value Value of the key\\n    function contextGet(string memory key) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = CONTEXT_GET.call(abi.encode(key));\\n        if (!success) {\\n            revert PeekerReverted(CONTEXT_GET, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Performs an HTTP request and returns the response. `request` is the request to perform.\\n    /// @param request Request to perform\\n    /// @return httpResponse Body of the response\\n    function doHTTPRequest(HttpRequest memory request) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = DO_HTTPREQUEST.call(abi.encode(request));\\n        if (!success) {\\n            revert PeekerReverted(DO_HTTPREQUEST, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Uses the `eth_call` JSON RPC method to let you simulate a function call and return the response.\\n    /// @param contractAddr Address of the contract to call\\n    /// @param input1 Data to send to the contract\\n    /// @return callOutput Output of the contract call\\n    function ethcall(address contractAddr, bytes memory input1) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = ETHCALL.call(abi.encode(contractAddr, input1));\\n        if (!success) {\\n            revert PeekerReverted(ETHCALL, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Interprets the bundle data and extracts hints, such as the `To` address and calldata.\\n    /// @param bundleData Bundle object encoded in JSON\\n    /// @return hints List of hints encoded in JSON\\n    function extractHint(bytes memory bundleData) internal returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = EXTRACT_HINT.call(abi.encode(bundleData));\\n        if (!success) {\\n            revert PeekerReverted(EXTRACT_HINT, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Retrieves all data records correlating with a specified decryption condition and namespace\\n    /// @param cond Filter for the decryption condition\\n    /// @param namespace Filter for the namespace of the data records\\n    /// @return dataRecords List of data records that match the filter\\n    function fetchDataRecords(uint64 cond, string memory namespace) internal returns (DataRecord[] memory) {\\n        (bool success, bytes memory data) = FETCH_DATA_RECORDS.call(abi.encode(cond, namespace));\\n        if (!success) {\\n            revert PeekerReverted(FETCH_DATA_RECORDS, data);\\n        }\\n\\n        return abi.decode(data, (DataRecord[]));\\n    }\\n\\n    /// @notice Joins the user's transaction and with the backrun, and returns encoded mev-share bundle. The bundle is ready to be sent via `SubmitBundleJsonRPC`.\\n    /// @param dataId ID of the data record with mev-share bundle data\\n    /// @return encodedBundle Mev-Share bundle encoded in JSON\\n    function fillMevShareBundle(DataId dataId) internal returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = FILL_MEV_SHARE_BUNDLE.call(abi.encode(dataId));\\n        if (!success) {\\n            revert PeekerReverted(FILL_MEV_SHARE_BUNDLE, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Initializes a new remote builder session\\n    /// @return sessionid ID of the remote builder session\\n    function newBuilder() internal returns (string memory) {\\n        (bool success, bytes memory data) = NEW_BUILDER.call(abi.encode());\\n        if (!success) {\\n            revert PeekerReverted(NEW_BUILDER, data);\\n        }\\n\\n        return abi.decode(data, (string));\\n    }\\n\\n    /// @notice Initializes data records within the ConfidentialStore. Prior to storing data, all data records should undergo initialization via this precompile.\\n    /// @param decryptionCondition Up to which block this data record is valid. Used during `fillMevShareBundle` precompie.\\n    /// @param allowedPeekers Addresses which can get data\\n    /// @param allowedStores Addresses can set data\\n    /// @param dataType Namespace of the data\\n    /// @return dataRecord Data record that was created\\n    function newDataRecord(\\n        uint64 decryptionCondition,\\n        address[] memory allowedPeekers,\\n        address[] memory allowedStores,\\n        string memory dataType\\n    ) internal returns (DataRecord memory) {\\n        (bool success, bytes memory data) =\\n            NEW_DATA_RECORD.call(abi.encode(decryptionCondition, allowedPeekers, allowedStores, dataType));\\n        if (!success) {\\n            revert PeekerReverted(NEW_DATA_RECORD, data);\\n        }\\n\\n        return abi.decode(data, (DataRecord));\\n    }\\n\\n    /// @notice Generates a private key in ECDA secp256k1 format\\n    /// @param crypto Type of the private key to generate\\n    /// @return privateKey Hex encoded string of the ECDSA private key. Exactly as a signMessage precompile wants.\\n    function privateKeyGen(CryptoSignature crypto) internal returns (string memory) {\\n        (bool success, bytes memory data) = PRIVATE_KEY_GEN.call(abi.encode(crypto));\\n        if (!success) {\\n            revert PeekerReverted(PRIVATE_KEY_GEN, data);\\n        }\\n\\n        return abi.decode(data, (string));\\n    }\\n\\n    /// @notice Generates a number of random bytes, given by the argument numBytes.\\n    /// @param numBytes Number of random bytes to generate\\n    /// @return value Randomly-generated bytes\\n    function randomBytes(uint8 numBytes) internal returns (bytes memory) {\\n        (bool success, bytes memory data) = RANDOM_BYTES.call(abi.encode(numBytes));\\n        if (!success) {\\n            revert PeekerReverted(RANDOM_BYTES, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Signs an Ethereum Transaction, 1559 or Legacy, and returns raw signed transaction bytes. `txn` is binary encoding of the transaction.\\n    /// @param txn Transaction to sign (RLP encoded)\\n    /// @param chainId Id of the chain to sign for (hex encoded, with 0x prefix)\\n    /// @param signingKey Hex encoded string of the ECDSA private key (without 0x prefix)\\n    /// @return signedTxn Signed transaction encoded in RLP\\n    function signEthTransaction(bytes memory txn, string memory chainId, string memory signingKey)\\n        internal\\n        returns (bytes memory)\\n    {\\n        (bool success, bytes memory data) = SIGN_ETH_TRANSACTION.call(abi.encode(txn, chainId, signingKey));\\n        if (!success) {\\n            revert PeekerReverted(SIGN_ETH_TRANSACTION, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Signs a message and returns the signature.\\n    /// @param digest Message to sign\\n    /// @param crypto Type of the private key to generate\\n    /// @param signingKey Hex encoded string of the ECDSA private key\\n    /// @return signature Signature of the message with the private key\\n    function signMessage(bytes memory digest, CryptoSignature crypto, string memory signingKey)\\n        internal\\n        returns (bytes memory)\\n    {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SIGN_MESSAGE.call(abi.encode(digest, crypto, signingKey));\\n        if (!success) {\\n            revert PeekerReverted(SIGN_MESSAGE, data);\\n        }\\n\\n        return abi.decode(data, (bytes));\\n    }\\n\\n    /// @notice Performs a simulation of the bundle by building a block that includes it.\\n    /// @param bundleData Bundle encoded in JSON\\n    /// @return effectiveGasPrice Effective Gas Price of the resultant block\\n    function simulateBundle(bytes memory bundleData) internal returns (uint64) {\\n        (bool success, bytes memory data) = SIMULATE_BUNDLE.call(abi.encode(bundleData));\\n        if (!success) {\\n            revert PeekerReverted(SIMULATE_BUNDLE, data);\\n        }\\n\\n        return abi.decode(data, (uint64));\\n    }\\n\\n    /// @notice Simulates a transaction on a remote builder session\\n    /// @param sessionid ID of the remote builder session\\n    /// @param txn Txn to simulate encoded in RLP\\n    /// @return simulationResult Result of the simulation\\n    function simulateTransaction(string memory sessionid, bytes memory txn)\\n        internal\\n        returns (SimulateTransactionResult memory)\\n    {\\n        (bool success, bytes memory data) = SIMULATE_TRANSACTION.call(abi.encode(sessionid, txn));\\n        if (!success) {\\n            revert PeekerReverted(SIMULATE_TRANSACTION, data);\\n        }\\n\\n        return abi.decode(data, (SimulateTransactionResult));\\n    }\\n\\n    /// @notice Submits bytes as JSONRPC message to the specified URL with the specified method. As this call is intended for bundles, it also signs the params and adds `X-Flashbots-Signature` header, as usual with bundles. Regular eth bundles don't need any processing to be sent.\\n    /// @param url URL to send the request to\\n    /// @param method JSONRPC method to call\\n    /// @param params JSONRPC input params encoded in RLP\\n    /// @return errorMessage Error message if any\\n    function submitBundleJsonRPC(string memory url, string memory method, bytes memory params)\\n        internal\\n        returns (bytes memory)\\n    {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SUBMIT_BUNDLE_JSON_RPC.call(abi.encode(url, method, params));\\n        if (!success) {\\n            revert PeekerReverted(SUBMIT_BUNDLE_JSON_RPC, data);\\n        }\\n\\n        return data;\\n    }\\n\\n    /// @notice Submits a given builderBid to a mev-boost relay.\\n    /// @param relayUrl URL of the relay to submit to\\n    /// @param builderBid Block bid to submit encoded in JSON\\n    /// @return blockBid Error message if any\\n    function submitEthBlockToRelay(string memory relayUrl, bytes memory builderBid) internal returns (bytes memory) {\\n        require(isConfidential());\\n        (bool success, bytes memory data) = SUBMIT_ETH_BLOCK_TO_RELAY.call(abi.encode(relayUrl, builderBid));\\n        if (!success) {\\n            revert PeekerReverted(SUBMIT_ETH_BLOCK_TO_RELAY, data);\\n        }\\n\\n        return data;\\n    }\\n}\\n\",\"keccak256\":\"0x3cd3eda525d8403668553d130780ecdca2bdee28bb82cc58a7c138c849409f9f\",\"license\":\"UNLICENSED\"},\"lib/suave-std/src/utils/HexStrings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Hex string to bytes parser. Used for decoding JSON encoded data.\\nlibrary HexStrings {\\n    function _fromHexChar(uint8 c) internal pure returns (uint8) {\\n        if (bytes1(c) >= bytes1(\\\"0\\\") && bytes1(c) <= bytes1(\\\"9\\\")) {\\n            return c - uint8(bytes1(\\\"0\\\"));\\n        }\\n        if (bytes1(c) >= bytes1(\\\"a\\\") && bytes1(c) <= bytes1(\\\"f\\\")) {\\n            return 10 + c - uint8(bytes1(\\\"a\\\"));\\n        }\\n        if (bytes1(c) >= bytes1(\\\"A\\\") && bytes1(c) <= bytes1(\\\"F\\\")) {\\n            return 10 + c - uint8(bytes1(\\\"A\\\"));\\n        }\\n        revert(\\\"fail\\\");\\n    }\\n\\n    // Convert an hexadecimal string to raw bytes\\n    function fromHexString(string memory s) internal pure returns (bytes memory) {\\n        bytes memory ss = bytes(s);\\n        require(ss.length % 2 == 0); // length must be even\\n        bytes memory r = new bytes(ss.length / 2);\\n        for (uint256 i = 0; i < ss.length / 2; ++i) {\\n            r[i] = bytes1(_fromHexChar(uint8(ss[2 * i])) * 16 + _fromHexChar(uint8(ss[2 * i + 1])));\\n        }\\n        return r;\\n    }\\n\\n    function stripQuotesAndPrefix(string memory s) internal pure returns (string memory) {\\n        bytes memory strBytes = bytes(s);\\n        bytes memory result = new bytes(strBytes.length - 4);\\n        for (uint256 i = 3; i < strBytes.length - 1; i++) {\\n            result[i - 3] = strBytes[i];\\n        }\\n        return string(result);\\n    }\\n}\\n\",\"keccak256\":\"0x2632940347ac7f306b56a84b44ed27f8f3b0e41f46ba90406f562ce4794423f5\",\"license\":\"MIT\"},\"solady/src/utils/JSONParserLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for parsing JSONs.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/JSONParserLib.sol)\\nlibrary JSONParserLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The input is invalid.\\n    error ParsingFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // There are 6 types of variables in JSON (excluding undefined).\\n\\n    /// @dev For denoting that an item has not been initialized.\\n    /// A item returned from `parse` will never be of an undefined type.\\n    /// Parsing a invalid JSON string will simply revert.\\n    uint8 internal constant TYPE_UNDEFINED = 0;\\n\\n    /// @dev Type representing an array (e.g. `[1,2,3]`).\\n    uint8 internal constant TYPE_ARRAY = 1;\\n\\n    /// @dev Type representing an object (e.g. `{\\\"a\\\":\\\"A\\\",\\\"b\\\":\\\"B\\\"}`).\\n    uint8 internal constant TYPE_OBJECT = 2;\\n\\n    /// @dev Type representing a number (e.g. `-1.23e+21`).\\n    uint8 internal constant TYPE_NUMBER = 3;\\n\\n    /// @dev Type representing a string (e.g. `\\\"hello\\\"`).\\n    uint8 internal constant TYPE_STRING = 4;\\n\\n    /// @dev Type representing a boolean (i.e. `true` or `false`).\\n    uint8 internal constant TYPE_BOOLEAN = 5;\\n\\n    /// @dev Type representing null (i.e. `null`).\\n    uint8 internal constant TYPE_NULL = 6;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pointer to a parsed JSON node.\\n    struct Item {\\n        // Do NOT modify the `_data` directly.\\n        uint256 _data;\\n    }\\n\\n    // Private constants for packing `_data`.\\n\\n    uint256 private constant _BITPOS_STRING = 32 * 7 - 8;\\n    uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;\\n    uint256 private constant _BITPOS_KEY = 32 * 5 - 8;\\n    uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;\\n    uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;\\n    uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;\\n    uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;\\n    uint256 private constant _BITMASK_POINTER = 0xffffffff;\\n    uint256 private constant _BITMASK_TYPE = 7;\\n    uint256 private constant _KEY_INITED = 1 << 3;\\n    uint256 private constant _VALUE_INITED = 1 << 4;\\n    uint256 private constant _CHILDREN_INITED = 1 << 5;\\n    uint256 private constant _PARENT_IS_ARRAY = 1 << 6;\\n    uint256 private constant _PARENT_IS_OBJECT = 1 << 7;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   JSON PARSING OPERATION                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Parses the JSON string `s`, and returns the root.\\n    /// Reverts if `s` is not a valid JSON as specified in RFC 8259.\\n    /// Object items WILL simply contain all their children, inclusive of repeated keys,\\n    /// in the same order which they appear in the JSON string.\\n    ///\\n    /// Note: For efficiency, this function WILL NOT make a copy of `s`.\\n    /// The parsed tree WILL contain offsets to `s`.\\n    /// Do NOT pass in a string that WILL be modified later on.\\n    function parse(string memory s) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // We will use our own allocation instead.\\n        }\\n        bytes32 r = _query(_toInput(s), 255);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    JSON ITEM OPERATIONS                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note:\\n    // - An item is a node in the JSON tree.\\n    // - The value of a string item WILL be double-quoted, JSON encoded.\\n    // - We make a distinction between `index` and `key`.\\n    //   - Items in arrays are located by `index` (uint256).\\n    //   - Items in objects are located by `key` (string).\\n    // - Keys are always strings, double-quoted, JSON encoded.\\n    //\\n    // These design choices are made to balance between efficiency and ease-of-use.\\n\\n    /// @dev Returns the string value of the item.\\n    /// This is its exact string representation in the original JSON string.\\n    /// The returned string WILL have leading and trailing whitespace trimmed.\\n    /// All inner whitespace WILL be preserved, exactly as it is in the original JSON string.\\n    /// If the item's type is string, the returned string WILL be double-quoted, JSON encoded.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned string.\\n    /// Do NOT modify the returned string.\\n    function value(Item memory item) internal pure returns (string memory result) {\\n        bytes32 r = _query(_toInput(item), 0);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /// @dev Returns the index of the item in the array.\\n    /// It the item's parent is not an array, returns 0.\\n    function index(Item memory item) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if and(mload(item), _PARENT_IS_ARRAY) {\\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the key of the item in the object.\\n    /// It the item's parent is not an object, returns an empty string.\\n    /// The returned string WILL be double-quoted, JSON encoded.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned string.\\n    /// Do NOT modify the returned string.\\n    function key(Item memory item) internal pure returns (string memory result) {\\n        if (item._data & _PARENT_IS_OBJECT != 0) {\\n            bytes32 r = _query(_toInput(item), 1);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                result := r\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the key of the item in the object.\\n    /// It the item is neither an array nor object, returns an empty array.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned array.\\n    /// Do NOT modify the returned array.\\n    function children(Item memory item) internal pure returns (Item[] memory result) {\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /// @dev Returns the number of children.\\n    /// It the item is neither an array nor object, returns zero.\\n    function size(Item memory item) internal pure returns (uint256 result) {\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(r)\\n        }\\n    }\\n\\n    /// @dev Returns the item at index `i` for (array).\\n    /// If `item` is not an array, the result's type WILL be undefined.\\n    /// If there is no item with the index, the result's type WILL be undefined.\\n    function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\\n        }\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(add(add(r, 0x20), shl(5, i)))\\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\\n                result := 0x60 // Reset to the zero pointer.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the item at key `k` for (object).\\n    /// If `item` is not an object, the result's type WILL be undefined.\\n    /// The key MUST be double-quoted, JSON encoded. This is for efficiency reasons.\\n    /// - Correct : `item.at('\\\"k\\\"')`.\\n    /// - Wrong   : `item.at(\\\"k\\\")`.\\n    /// For duplicated keys, the last item with the key WILL be returned.\\n    /// If there is no item with the key, the result's type WILL be undefined.\\n    function at(Item memory item, string memory k) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\\n            result := 0x60 // Initialize to the zero pointer.\\n        }\\n        if (isObject(item)) {\\n            bytes32 kHash = keccak256(bytes(k));\\n            Item[] memory r = children(item);\\n            // We'll just do a linear search. The alternatives are very bloated.\\n            for (uint256 i = r.length << 5; i != 0;) {\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    item := mload(add(r, i))\\n                    i := sub(i, 0x20)\\n                }\\n                if (keccak256(bytes(key(item))) != kHash) continue;\\n                result = item;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the item's type.\\n    function getType(Item memory item) internal pure returns (uint8 result) {\\n        result = uint8(item._data & _BITMASK_TYPE);\\n    }\\n\\n    /// Note: All types are mutually exclusive.\\n\\n    /// @dev Returns whether the item is of type undefined.\\n    function isUndefined(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\\n    }\\n\\n    /// @dev Returns whether the item is of type array.\\n    function isArray(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\\n    }\\n\\n    /// @dev Returns whether the item is of type object.\\n    function isObject(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\\n    }\\n\\n    /// @dev Returns whether the item is of type number.\\n    function isNumber(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\\n    }\\n\\n    /// @dev Returns whether the item is of type string.\\n    function isString(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\\n    }\\n\\n    /// @dev Returns whether the item is of type boolean.\\n    function isBoolean(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\\n    }\\n\\n    /// @dev Returns whether the item is of type null.\\n    function isNull(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\\n    }\\n\\n    /// @dev Returns the item's parent.\\n    /// If the item does not have a parent, the result's type will be undefined.\\n    function parent(Item memory item) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     UTILITY FUNCTIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Parses an unsigned integer from a string (in decimal, i.e. base 10).\\n    /// Reverts if `s` is not a valid uint256 string matching the RegEx `^[0-9]+$`,\\n    /// or if the parsed number is too big for a uint256.\\n    function parseUint(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            let preMulOverflowThres := div(not(0), 10)\\n            for { let i := 0 } 1 {} {\\n                i := add(i, 1)\\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\\n                let mulOverflowed := gt(result, preMulOverflowThres)\\n                let product := mul(10, result)\\n                result := add(product, digit)\\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\\n                if iszero(lt(i, n)) { break }\\n            }\\n            if iszero(n) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Parses a signed integer from a string (in decimal, i.e. base 10).\\n    /// Reverts if `s` is not a valid int256 string matching the RegEx `^[+-]?[0-9]+$`,\\n    /// or if the parsed number cannot fit within `[-2**255 .. 2**255 - 1]`.\\n    function parseInt(string memory s) internal pure returns (int256 result) {\\n        uint256 n = bytes(s).length;\\n        uint256 sign;\\n        uint256 isNegative;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if n {\\n                let c := and(mload(add(s, 1)), 0xff)\\n                isNegative := eq(c, 45)\\n                if or(eq(c, 43), isNegative) {\\n                    sign := c\\n                    s := add(s, 1)\\n                    mstore(s, sub(n, 1))\\n                }\\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\\n            }\\n        }\\n        uint256 x = parseUint(s);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, add(shl(255, 1), isNegative))) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sign {\\n                mstore(s, sign)\\n                s := sub(s, 1)\\n                mstore(s, n)\\n            }\\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\\n        }\\n    }\\n\\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number cannot fit within `[0 .. 2**256 - 1]`.\\n    function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            // Skip two if starts with '0x' or '0X'.\\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\\n            for {} 1 {} {\\n                i := add(i, 1)\\n                let c :=\\n                    byte(\\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\\n                        0x3010a071000000b0104040208000c05090d060e0f\\n                    )\\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\\n                result := add(shl(4, result), sub(c, 1))\\n                if iszero(lt(i, n)) { break }\\n            }\\n            if iszero(n) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Decodes a JSON encoded string.\\n    /// The string MUST be double-quoted, JSON encoded.\\n    /// Reverts if the string is invalid.\\n    /// As you can see, it's pretty complex for a deceptively simple looking task.\\n    function decodeString(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function fail() {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\\n                _pOut := add(pIn_, 4)\\n                let b_ := iszero(gt(_pOut, end_))\\n                let t_ := mload(pIn_) // Load the whole word.\\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\\n                    let c_ := sub(byte(i_, t_), 48)\\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\\n                    _unicode := add(shl(4, _unicode), c_)\\n                }\\n            }\\n\\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\\n                    let t_ := mload(_pOut) // Load the whole word.\\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\\\\\u'.\\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\\n                }\\n            }\\n\\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\\n                if iszero(gt(c_, 0x7f)) {\\n                    mstore8(pIn_, c_)\\n                    _pOut := add(pIn_, 1)\\n                    leave\\n                }\\n                mstore8(0x1f, c_)\\n                mstore8(0x1e, shr(6, c_))\\n                if iszero(gt(c_, 0x7ff)) {\\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\\n                    _pOut := add(pIn_, 2)\\n                    leave\\n                }\\n                mstore8(0x1d, shr(12, c_))\\n                if iszero(gt(c_, 0xffff)) {\\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\\n                    _pOut := add(pIn_, 3)\\n                    leave\\n                }\\n                mstore8(0x1c, shr(18, c_))\\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\\n            }\\n\\n            function chr(p_) -> _c {\\n                _c := byte(0, mload(p_))\\n            }\\n\\n            let n := mload(s)\\n            let end := add(add(s, n), 0x1f)\\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\\n                fail() // Fail if not double-quoted.\\n            }\\n            let out := add(mload(0x40), 0x20)\\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\\n                let c := chr(curr)\\n                curr := add(curr, 1)\\n                // Not '\\\\\\\\'.\\n                if iszero(eq(c, 92)) {\\n                    // Not '\\\"'.\\n                    if iszero(eq(c, 34)) {\\n                        mstore8(out, c)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                    curr := end\\n                }\\n                if iszero(eq(curr, end)) {\\n                    let escape := chr(curr)\\n                    curr := add(curr, 1)\\n                    // '\\\"', '/', '\\\\\\\\'.\\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\\n                        mstore8(out, escape)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                    // 'u'.\\n                    if eq(escape, 117) {\\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\\n                        out := appendCodePointAsUTF8(out, escape)\\n                        continue\\n                    }\\n                    // `{'b':'\\\\b', 'f':'\\\\f', 'n':'\\\\n', 'r':'\\\\r', 't':'\\\\t'}`.\\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\\n                    if escape {\\n                        mstore8(out, escape)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                }\\n                fail()\\n                break\\n            }\\n            mstore(out, 0) // Zeroize the last slot.\\n            result := mload(0x40)\\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Performs a query on the input with the given mode.\\n    function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function fail() {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            function chr(p_) -> _c {\\n                _c := byte(0, mload(p_))\\n            }\\n\\n            function skipWhitespace(pIn_, end_) -> _pOut {\\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\\\n\\\\r\\\\t'.\\n                }\\n            }\\n\\n            function setP(packed_, bitpos_, p_) -> _packed {\\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\\n            }\\n\\n            function getP(packed_, bitpos_) -> _p {\\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\\n            }\\n\\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\\n                _item := mload(0x40)\\n                // forgefmt: disable-next-item\\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\\n                mstore(_item, or(packed_, type_))\\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\\n            }\\n\\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\\n                _pOut := skipWhitespace(pIn_, end_)\\n                if iszero(lt(_pOut, end_)) { leave }\\n                for { let c_ := chr(_pOut) } 1 {} {\\n                    // If starts with '\\\"'.\\n                    if eq(c_, 34) {\\n                        let pStart_ := _pOut\\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\\n                        break\\n                    }\\n                    // If starts with '['.\\n                    if eq(c_, 91) {\\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    // If starts with '{'.\\n                    if eq(c_, 123) {\\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    // If starts with any in '0123456789-'.\\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    if iszero(gt(add(_pOut, 4), end_)) {\\n                        let pStart_ := _pOut\\n                        let w_ := shr(224, mload(_pOut))\\n                        // 'true' in hex format.\\n                        if eq(w_, 0x74727565) {\\n                            _pOut := add(_pOut, 4)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\\n                            break\\n                        }\\n                        // 'null' in hex format.\\n                        if eq(w_, 0x6e756c6c) {\\n                            _pOut := add(_pOut, 4)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\\n                            break\\n                        }\\n                    }\\n                    if iszero(gt(add(_pOut, 5), end_)) {\\n                        let pStart_ := _pOut\\n                        let w_ := shr(216, mload(_pOut))\\n                        // 'false' in hex format.\\n                        if eq(w_, 0x66616c7365) {\\n                            _pOut := add(_pOut, 5)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\\n                            break\\n                        }\\n                    }\\n                    fail()\\n                    break\\n                }\\n                _pOut := skipWhitespace(_pOut, end_)\\n            }\\n\\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                let j_ := 0\\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(_pOut, end_)) { fail() }\\n                    if iszero(_item) {\\n                        _pOut := skipWhitespace(_pOut, end_)\\n                        if eq(chr(_pOut), 93) { break } // ']'.\\n                    }\\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\\n                    if _item {\\n                        // forgefmt: disable-next-item\\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\\n                            _BITPOS_KEY, j_))\\n                        j_ := add(j_, 1)\\n                        let c_ := chr(_pOut)\\n                        if eq(c_, 93) { break } // ']'.\\n                        if eq(c_, 44) { continue } // ','.\\n                    }\\n                    _pOut := end_\\n                }\\n                _pOut := add(_pOut, 1)\\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\\n            }\\n\\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(_pOut, end_)) { fail() }\\n                    if iszero(_item) {\\n                        _pOut := skipWhitespace(_pOut, end_)\\n                        if eq(chr(_pOut), 125) { break } // '}'.\\n                    }\\n                    _pOut := skipWhitespace(_pOut, end_)\\n                    let pKeyStart_ := _pOut\\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\\n                    // If ':'.\\n                    if eq(chr(_pOut), 58) {\\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\\n                        if _item {\\n                            // forgefmt: disable-next-item\\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\\n                            let c_ := chr(_pOut)\\n                            if eq(c_, 125) { break } // '}'.\\n                            if eq(c_, 44) { continue } // ','.\\n                        }\\n                    }\\n                    _pOut := end_\\n                }\\n                _pOut := add(_pOut, 1)\\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\\n            }\\n\\n            function checkStringU(p_, o_) {\\n                // If not in '0123456789abcdefABCDEF', revert.\\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\\n            }\\n\\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\\n                if iszero(lt(pIn_, end_)) { fail() }\\n                for { _pOut := add(pIn_, 1) } 1 {} {\\n                    let c_ := chr(_pOut)\\n                    if eq(c_, 34) { break } // '\\\"'.\\n                    // Not '\\\\'.\\n                    if iszero(eq(c_, 92)) {\\n                        _pOut := add(_pOut, 1)\\n                        continue\\n                    }\\n                    c_ := chr(add(_pOut, 1))\\n                    // '\\\"', '\\\\', '//', 'b', 'f', 'n', 'r', 't'.\\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\\n                        _pOut := add(_pOut, 2)\\n                        continue\\n                    }\\n                    // 'u'.\\n                    if eq(c_, 117) {\\n                        checkStringU(_pOut, 2)\\n                        _pOut := add(_pOut, 6)\\n                        continue\\n                    }\\n                    _pOut := end_\\n                    break\\n                }\\n                if iszero(lt(_pOut, end_)) { fail() }\\n                _pOut := add(_pOut, 1)\\n            }\\n\\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\\n                }\\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\\n            }\\n\\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                _pOut := pIn_\\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\\n                let c_ := chr(_pOut)\\n                _pOut := add(_pOut, 1)\\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\\n                let t_ := mload(_pOut)\\n                // 'E', 'e'.\\n                if eq(or(0x20, byte(0, t_)), 101) {\\n                    // forgefmt: disable-next-item\\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\\n                        add(_pOut, 1)), end_, 1)\\n                }\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\\n            }\\n\\n            function copyStr(s_, offset_, len_) -> _sCopy {\\n                _sCopy := mload(0x40)\\n                s_ := add(s_, offset_)\\n                let w_ := not(0x1f)\\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\\n                    if iszero(i_) { break }\\n                }\\n                mstore(_sCopy, len_) // Copy the length.\\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\\n            }\\n\\n            function value(item_) -> _value {\\n                let packed_ := mload(item_)\\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\\n                if iszero(and(_VALUE_INITED, packed_)) {\\n                    let s_ := getP(packed_, _BITPOS_STRING)\\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\\n                    mstore(s_, or(_VALUE_INITED, packed_))\\n                }\\n            }\\n\\n            function children(item_) -> _arr {\\n                _arr := 0x60 // Initialize to the zero pointer.\\n                let packed_ := mload(item_)\\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\\n                    if or(iszero(packed_), iszero(item_)) { break }\\n                    if and(packed_, _CHILDREN_INITED) {\\n                        _arr := getP(packed_, _BITPOS_CHILD)\\n                        break\\n                    }\\n                    _arr := mload(0x40)\\n                    let o_ := add(_arr, 0x20)\\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\\n                        mstore(o_, h_)\\n                        let q_ := mload(h_)\\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\\n                        h_ := y_\\n                        o_ := add(o_, 0x20)\\n                    }\\n                    let w_ := not(0x1f)\\n                    let n_ := add(w_, sub(o_, _arr))\\n                    mstore(_arr, shr(5, n_))\\n                    mstore(0x40, o_) // Allocate memory.\\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\\n                    // Reverse the array.\\n                    if iszero(lt(n_, 0x40)) {\\n                        let lo_ := add(_arr, 0x20)\\n                        let hi_ := add(_arr, n_)\\n                        for {} 1 {} {\\n                            let temp_ := mload(lo_)\\n                            mstore(lo_, mload(hi_))\\n                            mstore(hi_, temp_)\\n                            hi_ := add(hi_, w_)\\n                            lo_ := add(lo_, 0x20)\\n                            if iszero(lt(lo_, hi_)) { break }\\n                        }\\n                    }\\n                    break\\n                }\\n            }\\n\\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\\n                _result := 0x60 // Initialize to the zero pointer.\\n                let packed_ := mload(item_)\\n                if or(iszero(item_), iszero(packed_)) { leave }\\n                _result := getP(packed_, bitpos_)\\n                if iszero(and(bitmaskInited_, packed_)) {\\n                    let s_ := getP(packed_, _BITPOS_STRING)\\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\\n                }\\n            }\\n\\n            switch mode\\n            // Get value.\\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\\n            // Get key.\\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\\n            // Get children.\\n            case 3 { result := children(input) }\\n            // Parse.\\n            default {\\n                let p := add(input, 0x20)\\n                let e := add(p, mload(input))\\n                if iszero(eq(p, e)) {\\n                    let c := chr(e)\\n                    mstore8(e, 34) // Place a '\\\"' at the end to speed up parsing.\\n                    // The `34 << 248` makes `mallocItem` preserve '\\\"' at the end.\\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\\n                    result, p := parseValue(input, 0, p, e)\\n                    mstore8(e, c) // Restore the original char at the end.\\n                }\\n                if or(lt(p, e), iszero(result)) { fail() }\\n            }\\n        }\\n    }\\n\\n    /// @dev Casts the input to a bytes32.\\n    function _toInput(string memory input) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := input\\n        }\\n    }\\n\\n    /// @dev Casts the input to a bytes32.\\n    function _toInput(Item memory input) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := input\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x24ddc4015b10af1bcf9eb4fd69d1e03a575698b0104b9ecc60c0c25464cd4d03\",\"license\":\"MIT\"},\"solady/src/utils/LibString.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// @dev Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The length of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// @dev The length of the string is more than 32 bytes.\\n    error TooBigForSmallString();\\n\\n    /// @dev The input string must be a 7-bit ASCII.\\n    error StringNot7BitASCII();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\\n    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;\\n\\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\\n    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;\\n\\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyz'.\\n    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;\\n\\n    /// @dev Lookup for 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\\n    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;\\n\\n    /// @dev Lookup for '0123456789'.\\n    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;\\n\\n    /// @dev Lookup for '0123456789abcdefABCDEF'.\\n    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;\\n\\n    /// @dev Lookup for '01234567'.\\n    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;\\n\\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&\\\\'()*+,-./:;<=>?@[\\\\\\\\]^_`{|}~ \\\\t\\\\n\\\\r\\\\x0b\\\\x0c'.\\n    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;\\n\\n    /// @dev Lookup for '!\\\"#$%&\\\\'()*+,-./:;<=>?@[\\\\\\\\]^_`{|}~'.\\n    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;\\n\\n    /// @dev Lookup for ' \\\\t\\\\n\\\\r\\\\x0b\\\\x0c'.\\n    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\\n            mstore(str, 0) // Zeroize the slot after the string.\\n\\n            let end := str // Cache the end of the memory to calculate the length later.\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Store the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\\n                if iszero(temp) { break }\\n            }\\n            let length := sub(end, str)\\n            str := sub(str, 0x20) // Move the pointer 32 bytes back to make room for the length.\\n            mstore(str, length) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) return toString(uint256(value));\\n        unchecked {\\n            str = toString(~uint256(value) + 1);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Store the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\\n            mstore(str, 0) // Zeroize the slot after the string.\\n\\n            let end := str // Cache the end to calculate the length later.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n            if temp {\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let strLength := sub(end, str)\\n            str := sub(str, 0x20)\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Store the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Store the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Store the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Store the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\\n            mstore(str, 0) // Zeroize the slot after the string.\\n\\n            let end := str // Cache the end to calculate the length later.\\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \\\"0123456789abcdef\\\" lookup.\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n            let strLength := sub(end, str)\\n            str := sub(str, 0x20)\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Store the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \\\"0123456789abcdef\\\" lookup.\\n\\n            str := add(str, 2)\\n            mstore(str, 40) // Store the length.\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\\n            value := shl(96, value)\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Store the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \\\"0123456789abcdef\\\" lookup.\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string,\\n    /// AND all characters are in the `allowed` lookup.\\n    /// Note: If `s` is empty, returns true regardless of `allowed`.\\n    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            if mload(s) {\\n                let allowed_ := shr(128, shl(128, allowed))\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for {} 1 {} {\\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\\n                    o := add(o, 1)\\n                    if iszero(and(result, lt(o, end))) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Converts the bytes in the 7-bit ASCII string `s` to\\n    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.\\n    /// To save runtime gas, you can cache the result in an immutable variable.\\n    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for {} 1 {} {\\n                    result := or(result, shl(byte(0, mload(o)), 1))\\n                    o := add(o, 1)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                if shr(128, result) {\\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // For performance and bytecode compactness, byte string operations are restricted\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\n    // can lead to undefined behavior.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                mstore(0x40, add(result, add(resultLength, 0x40))) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                mstore(0x40, add(result, add(resultLength, 0x40))) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            mstore(result, totalLength) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `s` must be null-terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n            mstore(result, n) // Store the length.\\n            let o := add(result, 0x20)\\n            mstore(o, s) // Store the bytes of the string.\\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(result, 0x40)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n            mstore(0x00, s)\\n            mstore(result, 0x00)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the string as a normalized null-terminated small string.\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(s)\\n            if iszero(lt(result, 33)) {\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40) // Grab the free memory pointer.\\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(result, 0) // Zeroize the length slot.\\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    or( // Load the length and the bytes of `a` and `b`.\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            resultA := mload(0x40) // Grab the free memory pointer.\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retUnpaddedSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retUnpaddedSize), 0)\\n            mstore(retStart, 0x20) // Store the return offset.\\n            // End the transaction, returning the string.\\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbb90caa572b7f65689b74867ec211fed8cde92714314101f4287d00a40d95ab2\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c06040523373ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff16815250604051620000459062000196565b604051809103906000f08015801562000062573d6000803e3d6000fd5b5073ffffffffffffffffffffffffffffffffffffffff1660a09073ffffffffffffffffffffffffffffffffffffffff16815250348015620000a257600080fd5b506040516200bb5c3803806200bb5c8339818101604052810190620000c89190620003b4565b818181600360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600081836040516200011d90620001a4565b6200012a92919062000488565b604051809103906000f08015801562000147573d6000803e3d6000fd5b50905080600660016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050505050620004bc565b612662806200594083390190565b613bba8062007fa283390190565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000620001f382620001c6565b9050919050565b6200020581620001e6565b81146200021157600080fd5b50565b6000815190506200022581620001fa565b92915050565b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b620002808262000235565b810181811067ffffffffffffffff82111715620002a257620002a162000246565b5b80604052505050565b6000620002b7620001b2565b9050620002c5828262000275565b919050565b600067ffffffffffffffff821115620002e857620002e762000246565b5b620002f38262000235565b9050602081019050919050565b60005b838110156200032057808201518184015260208101905062000303565b8381111562000330576000848401525b50505050565b60006200034d6200034784620002ca565b620002ab565b9050828152602081018484840111156200036c576200036b62000230565b5b6200037984828562000300565b509392505050565b600082601f8301126200039957620003986200022b565b5b8151620003ab84826020860162000336565b91505092915050565b60008060408385031215620003ce57620003cd620001bc565b5b6000620003de8582860162000214565b925050602083015167ffffffffffffffff811115620004025762000401620001c1565b5b620004108582860162000381565b9150509250929050565b600081519050919050565b600082825260208201905092915050565b600062000443826200041a565b6200044f818562000425565b93506200046181856020860162000300565b6200046c8162000235565b840191505092915050565b6200048281620001e6565b82525050565b60006040820190508181036000830152620004a4818562000436565b9050620004b5602083018462000477565b9392505050565b60805160a0516154116200052f6000396000818161073f015281816110e7015281816113ca01528181611539015281816115d9015281816121f8015281816122b6015281816123fd01526124aa01526000818161086f0152818161185d015281816118840152611c7401526154116000f3fe608060405234801561001057600080fd5b506004361061012f5760003560e01c8063617e3cb7116100ad57806396b5a7551161007157806396b5a7551461034a578063aad09be314610366578063c0631ea514610384578063da5cea8c146103a2578063fbfa77cf146103be57610130565b8063617e3cb7146102ba5780637e48532c146102d65780638528dbdf146102f457806389c438a2146103105780638c9043e61461032e57610130565b8063392e53cd116100f4578063392e53cd146101fa5780634ca89c2c14610218578063571a26a01461023657806357fcc1a51461026e5780635bbdb7561461028a57610130565b8062d23ce81461013257806309f73940146101625780631ed55ecc1461017e57806326d09ad5146101ae5780632f125731146101ca57610130565b5b005b61014c600480360381019061014791906132a1565b6103dc565b604051610159919061330f565b60405180910390f35b61017c60048036038101906101779190613364565b6104a7565b005b610198600480360381019061019391906134f1565b61068c565b6040516101a591906135a6565b60405180910390f35b6101c860048036038101906101c39190613656565b61086a565b005b6101e460048036038101906101df9190613696565b61092b565b6040516101f191906135a6565b60405180910390f35b610202610d59565b60405161020f919061330f565b60405180910390f35b610220610d6c565b60405161022d91906136d2565b60405180910390f35b610250600480360381019061024b91906136ed565b610d92565b604051610265999897969594939291906137ef565b60405180910390f35b610288600480360381019061028391906138cc565b610ea2565b005b6102a4600480360381019061029f9190613696565b610fcf565b6040516102b191906135a6565b60405180910390f35b6102d460048036038101906102cf9190613696565b611200565b005b6102de6114c9565b6040516102eb91906135a6565b60405180910390f35b61030e60048036038101906103099190613a79565b611708565b005b61031861185b565b60405161032591906136d2565b60405180910390f35b61034860048036038101906103439190613b25565b61187f565b005b610364600480360381019061035f91906136ed565b611abe565b005b61036e611c6d565b60405161037b91906135a6565b60405180910390f35b61038c611dba565b604051610399919061330f565b60405180910390f35b6103bc60048036038101906103b79190613ba8565b611dca565b005b6103c661202e565b6040516103d391906136d2565b60405180910390f35b6000806000600660019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f8b2cb4f876040518263ffffffff1660e01b815260040161043c91906136d2565b60408051808303816000875af115801561045a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061047e9190613c4e565b9150915084821015801561049c5750838167ffffffffffffffff1610155b925050509392505050565b600060058461ffff16815481106104c1576104c0613c8e565b5b90600052602060002090600602019050600060028111156104e5576104e461371a565b5b8160000160149054906101000a900460ff1660028111156105095761050861371a565b5b14610549576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161054090613d1a565b60405180910390fd5b8060030160049054906101000a900467ffffffffffffffff1667ffffffffffffffff164211156105ae576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105a590613d86565b60405180910390fd5b600082116105f1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105e890613e18565b60405180910390fd5b6000610643848484600301600c9054906101000a900467ffffffffffffffff168560030160049054906101000a900467ffffffffffffffff166106349190613e67565b67ffffffffffffffff166103dc565b905080610685576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161067c90613ef1565b60405180910390fd5b5050505050565b60606106d4610699612054565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c0000000000000000000000000000000081525061211e565b600660009054906101000a900460ff16610723576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161071a90613f5d565b60405180910390fd5b600061072d612164565b905060008180519060200120905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b8106b56846040518263ffffffff1660e01b815260040161079691906135a6565b6020604051808303816000875af11580156107b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d99190613f92565b905063da5cea8c60e01b858333846107ef6121a9565b60405160240161080395949392919061405d565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050509350505050919050565b6108f77f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600c81526020017f556e617574686f72697a6564000000000000000000000000000000000000000081525061211e565b81600181905550806000806101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055505050565b6060610973610938612054565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c0000000000000000000000000000000081525061211e565b600660009054906101000a900460ff166109c2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109b990613f5d565b60405180910390fd5b600060058361ffff16815481106109dc576109db613c8e565b5b9060005260206000209060060201905060006002811115610a00576109ff61371a565b5b8160000160149054906101000a900460ff166002811115610a2457610a2361371a565b5b14610a64576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a5b90613d1a565b60405180910390fd5b8060030160049054906101000a900467ffffffffffffffff1667ffffffffffffffff164211610ac8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610abf906140fd565b60405180910390fd5b60008160030160009054906101000a900463ffffffff1663ffffffff1611610b25576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b1c90614169565b60405180910390fd5b600080610b31856121eb565b9150915060006040518060a00160405280600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018560000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600660019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663aa43ef568760000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401610c3f91906136d2565b6020604051808303816000875af1158015610c5e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c82919061419e565b61ffff168152602001846020015173ffffffffffffffffffffffffffffffffffffffff1681526020018381525090506000610cbc826122b0565b9050638528dbdf60e01b87856000015186602001518585610cdb6121a9565b604051602401610cf096959493929190614260565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505095505050505050919050565b600660009054906101000a900460ff1681565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60058181548110610da257600080fd5b90600052602060002090600602016000915090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060000160149054906101000a900460ff16908060010160009054906101000a900460801b908060020154908060030160009054906101000a900463ffffffff16908060030160049054906101000a900467ffffffffffffffff169080600301600c9054906101000a900467ffffffffffffffff16908060040160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060050160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905089565b80610eee610eb382600001356123c5565b6040518060400160405280600b81526020017f496e76616c6964206b657900000000000000000000000000000000000000000081525061211e565b60058561ffff1681548110610f0657610f05613c8e565b5b9060005260206000209060060201600301600081819054906101000a900463ffffffff1680929190610f37906142cb565b91906101000a81548163ffffffff021916908363ffffffff160217905550508273ffffffffffffffffffffffffffffffffffffffff168463ffffffff168661ffff167f5fcb419af364578136edb4adbd64aff3d15c2301b8a8a7af01d49f82f82dfcb860405160405180910390a4806020013560018190555060026000815480929190610fc3906142f7565b91905055505050505050565b6060611017610fdc612054565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c0000000000000000000000000000000081525061211e565b600660009054906101000a900460ff16611066576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161105d90613f5d565b60405180910390fd5b6000611070612164565b806020019051810190611083919061433f565b905060003390506110958482846104a7565b60006110a8856110a36123f9565b612553565b9050600060405180606001604052808363ffffffff1681526020018473ffffffffffffffffffffffffffffffffffffffff1681526020018581525090507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166342bef59b82886040518363ffffffff1660e01b81526004016111409291906143bd565b600060405180830381600087803b15801561115a57600080fd5b505af115801561116e573d6000803e3d6000fd5b505050506357fcc1a560e01b8683856111856121a9565b60405160240161119894939291906143e6565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050945050505050919050565b61124661120b612054565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c0000000000000000000000000000000081525061211e565b600660009054906101000a900460ff16611295576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161128c90613f5d565b60405180910390fd5b600060058261ffff16815481106112af576112ae613c8e565b5b906000526020600020906006020190506002808111156112d2576112d161371a565b5b8160000160149054906101000a900460ff1660028111156112f6576112f561371a565b5b14611336576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161132d90614477565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff168160050160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146113c8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113bf906144e3565b60405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663986d666f8260010160009054906101000a900460801b6040518263ffffffff1660e01b81526004016114329190614503565b6000604051808303816000875af1158015611451573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061147a919061458e565b80602001905181019061148d9190614678565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114c09190614705565b60405180910390fd5b606061151a600660009054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a65640000000000000000000000000081525061211e565b6000611526600061256c565b9050600061153382612665565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16634faac5af846040518263ffffffff1660e01b815260040161159091906135a6565b6020604051808303816000875af11580156115af573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115d39190613f92565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16634fb6aefa60006040518263ffffffff1660e01b8152600401611631919061476c565b6020604051808303816000875af1158015611650573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116749190613f92565b90506000611680611c6d565b9050638c9043e660e01b838386846040516024016116a19493929190614787565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050509550505050505090565b8061175461171982600001356123c5565b6040518060400160405280600b81526020017f496e76616c6964206b657900000000000000000000000000000000000000000081525061211e565b600060058861ffff168154811061176e5761176d613c8e565b5b9060005260206000209060060201905060028160000160146101000a81548160ff021916908360028111156117a6576117a561371a565b5b0217905550858160050160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508761ffff167f911af55ab638b0215837b0ab0ab963a9b439db2c329ebbf57e981edb1ee8cd4d888787604051611826939291906147d3565b60405180910390a25080602001356001819055506002600081548092919061184d906142f7565b919050555050505050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b61190c7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600c81526020017f556e617574686f72697a6564000000000000000000000000000000000000000081525061211e565b600660009054906101000a900460ff161561195c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016119539061485d565b60405180910390fd5b82600760106101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555083600760006101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555081600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001600660006101000a81548160ff02191690831515021790555060003073ffffffffffffffffffffffffffffffffffffffff1682604051611a3391906148b9565b600060405180830381855af49150503d8060008114611a6e576040519150601f19603f3d011682016040523d82523d6000602084013e611a73565b606091505b5050905080611ab7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611aae90614942565b60405180910390fd5b5050505050565b600060058281548110611ad457611ad3613c8e565b5b906000526020600020906006020190503373ffffffffffffffffffffffffffffffffffffffff168160040160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614611b76576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611b6d906149ae565b60405180910390fd5b60006002811115611b8a57611b8961371a565b5b8160000160149054906101000a900460ff166002811115611bae57611bad61371a565b5b14611bee576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611be590613d1a565b60405180910390fd5b600160058381548110611c0457611c03613c8e565b5b906000526020600020906006020160000160146101000a81548160ff02191690836002811115611c3757611c3661371a565b5b0217905550817f2809c7e17bf978fbc7194c0a694b638c4215e9140cacc6c38ca36010b45697df60405160405180910390a25050565b6060611cfc7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600c81526020017f556e617574686f72697a6564000000000000000000000000000000000000000081525061211e565b6000611d0860206126d1565b90506000611d15826127ca565b90506000611d3883806020019051810190611d3091906149e3565b6002546129a6565b90506326d09ad560e01b8183604051602401611d55929190614a10565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050935050505090565b60008060001b6001541415905090565b80611e16611ddb82600001356123c5565b6040518060400160405280600b81526020017f496e76616c6964206b657900000000000000000000000000000000000000000081525061211e565b6000866000015142611e289190613e67565b905060006005600181600181540180825580915050039060005260206000209060060201905060008160000160146101000a81548160ff02191690836002811115611e7657611e7561371a565b5b021790555087604001518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550868160020181905550818160030160046101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550876020015181600301600c6101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550858160040160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550848160010160006101000a8154816fffffffffffffffffffffffffffffffff021916908360801c0217905550868673ffffffffffffffffffffffffffffffffffffffff166001600580549050611fbe9190614a39565b7f216b9e3e12e47255d565cd84569baa0c9998c971b9b8631c092eea22c8ed9e338b60400151868d60200151604051611ff993929190614a6d565b60405180910390a45050806020013560018190555060026000815480929190612021906142f7565b9190505550505050505050565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000806000634201000073ffffffffffffffffffffffffffffffffffffffff1660405161208090614aca565b6000604051808303816000865af19150503d80600081146120bd576040519150601f19603f3d011682016040523d82523d6000602084013e6120c2565b606091505b50915091508161210f576342010000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612106929190614adf565b60405180910390fd5b80516020820151935050505090565b8161216057806040517f0c25cd980000000000000000000000000000000000000000000000000000000081526004016121579190614705565b60405180910390fd5b5050565b60606121a46040518060400160405280601281526020017f636f6e666964656e7469616c496e7075747300000000000000000000000000008152506129e0565b905090565b6121b1613136565b60405180604001604052806121c7600254612ad9565b81526020016121e360016002546121de9190614b0f565b612af3565b815250905090565b6121f3613156565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f06d3450856040518263ffffffff1660e01b815260040161224f9190614b65565b6000604051808303816000875af115801561226e573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906122979190614cd6565b90506122a281612b2b565b809350819450505050915091565b606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16637891d72f600760009054906101000a900460801b6040518263ffffffff1660e01b815260040161231c9190614503565b6000604051808303816000875af115801561233b573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906123649190614678565b90506000836040516020016123799190614d1f565b6040516020818303038152906040528051906020012090506123bc816040516020016123a59190614d5b565b604051602081830303815290604052600084612bbf565b92505050919050565b6000600154826040516020016123db9190614d76565b60405160208183030381529060405280519060200120149050919050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663e596febd600760109054906101000a900460801b6040518263ffffffff1660e01b81526004016124639190614503565b6020604051808303816000875af1158015612482573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124a6919061419e565b90507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631b5095ef600760109054906101000a900460801b6001846125019190614d91565b6040518363ffffffff1660e01b815260040161251e929190614dc9565b600060405180830381600087803b15801561253857600080fd5b505af115801561254c573d6000803e3d6000fd5b5050505090565b60008160108461ffff16901b1761ffff16905092915050565b6060600080635320000373ffffffffffffffffffffffffffffffffffffffff168460405160200161259d9190614e3a565b6040516020818303038152906040526040516125b991906148b9565b6000604051808303816000865af19150503d80600081146125f6576040519150601f19603f3d011682016040523d82523d6000602084013e6125fb565b606091505b509150915081612648576353200003816040517f75fff46700000000000000000000000000000000000000000000000000000000815260040161263f929190614adf565b60405180910390fd5b8080602001905181019061265c9190614678565b92505050919050565b60008060405160200161267790614ea1565b60405160208183030381529060405280519060200120905060006126bc826040516020016126a59190614d5b565b604051602081830303815290604052600086612bbf565b90506126c88282612ccf565b92505050919050565b6060600080637770000b73ffffffffffffffffffffffffffffffffffffffff16846040516020016127029190614edd565b60405160208183030381529060405260405161271e91906148b9565b6000604051808303816000865af19150503d806000811461275b576040519150601f19603f3d011682016040523d82523d6000602084013e612760565b606091505b5091509150816127ad57637770000b816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016127a4929190614adf565b60405180910390fd5b808060200190518101906127c1919061458e565b92505050919050565b600080600367ffffffffffffffff8111156127e8576127e76133cd565b5b6040519080825280602002602001820160405280156128165781602001602082028036833780820191505090505b509050308160008151811061282e5761282d613c8e565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420300018160018151811061288157612880613c8e565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506342020001816002815181106128d4576128d3613c8e565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506000612952600083846040518060400160405280601181526020017f626c6f636b61643a76303a736563726574000000000000000000000000000000815250612d3e565b905061299881600001516040518060400160405280601181526020017f626c6f636b61643a76303a73656372657400000000000000000000000000000081525086612e46565b806000015192505050919050565b60006129b28383612f2b565b6040516020016129c29190614d76565b60405160208183030381529060405280519060200120905092915050565b6060600080635330000373ffffffffffffffffffffffffffffffffffffffff1684604051602001612a119190614705565b604051602081830303815290604052604051612a2d91906148b9565b6000604051808303816000865af19150503d8060008114612a6a576040519150601f19603f3d011682016040523d82523d6000602084013e612a6f565b606091505b509150915081612abc576353300003816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612ab3929190614adf565b60405180910390fd5b80806020019051810190612ad0919061458e565b92505050919050565b6000612aec612ae6612f5e565b83612f2b565b9050919050565b6000612afe82612ad9565b604051602001612b0e9190614d76565b604051602081830303815290604052805190602001209050919050565b612b33613156565b600080600090505b8351811015612ba9576000848281518110612b5957612b58613c8e565b5b60200260200101519050836040015181604001511115612b825783604001519250809350612b97565b8281604001511115612b9657806040015192505b5b5080612ba2906142f7565b9050612b3b565b5060008103612bba57816040015190505b915091565b6060612bc9612054565b612bd257600080fd5b600080634010000373ffffffffffffffffffffffffffffffffffffffff16868686604051602001612c0593929190614ef8565b604051602081830303815290604052604051612c2191906148b9565b6000604051808303816000865af19150503d8060008114612c5e576040519150601f19603f3d011682016040523d82523d6000602084013e612c63565b606091505b509150915081612cb0576340100003816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612ca7929190614adf565b60405180910390fd5b80806020019051810190612cc4919061458e565b925050509392505050565b600080600080612cde85612fc9565b92509250925060018682858560405160008152602001604052604051612d079493929190614f3d565b6020604051602081039080840390855afa158015612d29573d6000803e3d6000fd5b50505060206040510351935050505092915050565b612d46613193565b600080634203000073ffffffffffffffffffffffffffffffffffffffff1687878787604051602001612d7b9493929190615031565b604051602081830303815290604052604051612d9791906148b9565b6000604051808303816000865af19150503d8060008114612dd4576040519150601f19603f3d011682016040523d82523d6000602084013e612dd9565b606091505b509150915081612e26576342030000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612e1d929190614adf565b60405180910390fd5b80806020019051810190612e3a9190615242565b92505050949350505050565b600080634202000073ffffffffffffffffffffffffffffffffffffffff16858585604051602001612e799392919061528b565b604051602081830303815290604052604051612e9591906148b9565b6000604051808303816000865af19150503d8060008114612ed2576040519150601f19603f3d011682016040523d82523d6000602084013e612ed7565b606091505b509150915081612f24576342020000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612f1b929190614adf565b60405180910390fd5b5050505050565b60008282604051602001612f409291906152df565b60405160208183030381529060405280519060200120905092915050565b600080612fad60008054906101000a900460801b6040518060400160405280601181526020017f626c6f636b61643a76303a73656372657400000000000000000000000000000081525061304d565b905080806020019051810190612fc391906149e3565b91505090565b60008060006041845114613012576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161300990615354565b60405180910390fd5b6020840151925060408401519150606084015160001a9050601b8160ff16101561304657601b816130439190615374565b90505b9193909250565b6060600080634202000173ffffffffffffffffffffffffffffffffffffffff1685856040516020016130809291906153ab565b60405160208183030381529060405260405161309c91906148b9565b6000604051808303816000865af19150503d80600081146130d9576040519150601f19603f3d011682016040523d82523d6000602084013e6130de565b606091505b50915091508161312b576342020001816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401613122929190614adf565b60405180910390fd5b809250505092915050565b604051806040016040528060008019168152602001600080191681525090565b6040518060600160405280600063ffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600081525090565b6040518060c0016040528060006fffffffffffffffffffffffffffffffff1916815260200160006fffffffffffffffffffffffffffffffff19168152602001600067ffffffffffffffff1681526020016060815260200160608152602001606081525090565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006132388261320d565b9050919050565b6132488161322d565b811461325357600080fd5b50565b6000813590506132658161323f565b92915050565b6000819050919050565b61327e8161326b565b811461328957600080fd5b50565b60008135905061329b81613275565b92915050565b6000806000606084860312156132ba576132b9613203565b5b60006132c886828701613256565b93505060206132d98682870161328c565b92505060406132ea8682870161328c565b9150509250925092565b60008115159050919050565b613309816132f4565b82525050565b60006020820190506133246000830184613300565b92915050565b600061ffff82169050919050565b6133418161332a565b811461334c57600080fd5b50565b60008135905061335e81613338565b92915050565b60008060006060848603121561337d5761337c613203565b5b600061338b8682870161334f565b935050602061339c86828701613256565b92505060406133ad8682870161328c565b9150509250925092565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b613405826133bc565b810181811067ffffffffffffffff82111715613424576134236133cd565b5b80604052505050565b60006134376131f9565b905061344382826133fc565b919050565b600080fd5b600067ffffffffffffffff82169050919050565b61346a8161344d565b811461347557600080fd5b50565b60008135905061348781613461565b92915050565b6000606082840312156134a3576134a26133b7565b5b6134ad606061342d565b905060006134bd84828501613478565b60008301525060206134d184828501613478565b60208301525060406134e584828501613256565b60408301525092915050565b60006060828403121561350757613506613203565b5b60006135158482850161348d565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561355857808201518184015260208101905061353d565b83811115613567576000848401525b50505050565b60006135788261351e565b6135828185613529565b935061359281856020860161353a565b61359b816133bc565b840191505092915050565b600060208201905081810360008301526135c0818461356d565b905092915050565b6000819050919050565b6135db816135c8565b81146135e657600080fd5b50565b6000813590506135f8816135d2565b92915050565b60007fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b613633816135fe565b811461363e57600080fd5b50565b6000813590506136508161362a565b92915050565b6000806040838503121561366d5761366c613203565b5b600061367b858286016135e9565b925050602061368c85828601613641565b9150509250929050565b6000602082840312156136ac576136ab613203565b5b60006136ba8482850161334f565b91505092915050565b6136cc8161322d565b82525050565b60006020820190506136e760008301846136c3565b92915050565b60006020828403121561370357613702613203565b5b60006137118482850161328c565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6003811061375a5761375961371a565b5b50565b600081905061376b82613749565b919050565b600061377b8261375d565b9050919050565b61378b81613770565b82525050565b600061379c826135fe565b9050919050565b6137ac81613791565b82525050565b6137bb816135c8565b82525050565b600063ffffffff82169050919050565b6137da816137c1565b82525050565b6137e98161344d565b82525050565b600061012082019050613805600083018c6136c3565b613812602083018b613782565b61381f604083018a6137a3565b61382c60608301896137b2565b61383960808301886137d1565b61384660a08301876137e0565b61385360c08301866137e0565b61386060e08301856136c3565b61386e6101008301846136c3565b9a9950505050505050505050565b613885816137c1565b811461389057600080fd5b50565b6000813590506138a28161387c565b92915050565b600080fd5b6000604082840312156138c3576138c26138a8565b5b81905092915050565b60008060008060a085870312156138e6576138e5613203565b5b60006138f48782880161334f565b945050602061390587828801613893565b935050604061391687828801613256565b9250506060613927878288016138ad565b91505092959194509250565b600060a08284031215613949576139486133b7565b5b61395360a061342d565b9050600061396384828501613256565b600083015250602061397784828501613256565b602083015250604061398b8482850161334f565b604083015250606061399f84828501613256565b60608301525060806139b38482850161328c565b60808301525092915050565b600080fd5b600080fd5b600067ffffffffffffffff8211156139e4576139e36133cd565b5b6139ed826133bc565b9050602081019050919050565b82818337600083830152505050565b6000613a1c613a17846139c9565b61342d565b905082815260208101848484011115613a3857613a376139c4565b5b613a438482856139fa565b509392505050565b600082601f830112613a6057613a5f6139bf565b5b8135613a70848260208601613a09565b91505092915050565b6000806000806000806101608789031215613a9757613a96613203565b5b6000613aa589828a0161334f565b9650506020613ab689828a01613893565b9550506040613ac789828a01613256565b9450506060613ad889828a01613933565b93505061010087013567ffffffffffffffff811115613afa57613af9613208565b5b613b0689828a01613a4b565b925050610120613b1889828a016138ad565b9150509295509295509295565b60008060008060808587031215613b3f57613b3e613203565b5b6000613b4d87828801613641565b9450506020613b5e87828801613641565b9350506040613b6f87828801613256565b925050606085013567ffffffffffffffff811115613b9057613b8f613208565b5b613b9c87828801613a4b565b91505092959194509250565b60008060008060006101008688031215613bc557613bc4613203565b5b6000613bd38882890161348d565b9550506060613be4888289016135e9565b9450506080613bf588828901613256565b93505060a0613c0688828901613641565b92505060c0613c17888289016138ad565b9150509295509295909350565b600081519050613c3381613275565b92915050565b600081519050613c4881613461565b92915050565b60008060408385031215613c6557613c64613203565b5b6000613c7385828601613c24565b9250506020613c8485828601613c39565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600082825260208201905092915050565b7f41756374696f6e206973206e6f74206c69766500000000000000000000000000600082015250565b6000613d04601383613cbd565b9150613d0f82613cce565b602082019050919050565b60006020820190508181036000830152613d3381613cf7565b9050919050565b7f41756374696f6e2068617320656e646564000000000000000000000000000000600082015250565b6000613d70601183613cbd565b9150613d7b82613d3a565b602082019050919050565b60006020820190508181036000830152613d9f81613d63565b9050919050565b7f42696420616d6f756e742073686f756c6420626520677265617465722074686160008201527f6e207a65726f0000000000000000000000000000000000000000000000000000602082015250565b6000613e02602683613cbd565b9150613e0d82613da6565b604082019050919050565b60006020820190508181036000830152613e3181613df5565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000613e728261344d565b9150613e7d8361344d565b92508267ffffffffffffffff03821115613e9a57613e99613e38565b5b828201905092915050565b7f496e73756666696369656e742066756e64730000000000000000000000000000600082015250565b6000613edb601283613cbd565b9150613ee682613ea5565b602082019050919050565b60006020820190508181036000830152613f0a81613ece565b9050919050565b7f4e6f7420696e697469616c697a65640000000000000000000000000000000000600082015250565b6000613f47600f83613cbd565b9150613f5282613f11565b602082019050919050565b60006020820190508181036000830152613f7681613f3a565b9050919050565b600081519050613f8c8161362a565b92915050565b600060208284031215613fa857613fa7613203565b5b6000613fb684828501613f7d565b91505092915050565b613fc88161344d565b82525050565b613fd78161322d565b82525050565b606082016000820151613ff36000850182613fbf565b5060208201516140066020850182613fbf565b5060408201516140196040850182613fce565b50505050565b614028816135c8565b82525050565b604082016000820151614044600085018261401f565b506020820151614057602085018261401f565b50505050565b6000610100820190506140736000830188613fdd565b61408060608301876137b2565b61408d60808301866136c3565b61409a60a08301856137a3565b6140a760c083018461402e565b9695505050505050565b7f41756374696f6e20686173206e6f7420656e6465640000000000000000000000600082015250565b60006140e7601583613cbd565b91506140f2826140b1565b602082019050919050565b60006020820190508181036000830152614116816140da565b9050919050565b7f4e6f206269647300000000000000000000000000000000000000000000000000600082015250565b6000614153600783613cbd565b915061415e8261411d565b602082019050919050565b6000602082019050818103600083015261418281614146565b9050919050565b60008151905061419881613338565b92915050565b6000602082840312156141b4576141b3613203565b5b60006141c284828501614189565b91505092915050565b6141d48161332a565b82525050565b6141e38161332a565b82525050565b6141f28161326b565b82525050565b60a08201600082015161420e6000850182613fce565b5060208201516142216020850182613fce565b50604082015161423460408501826141da565b5060608201516142476060850182613fce565b50608082015161425a60808501826141e9565b50505050565b60006101608201905061427660008301896141cb565b61428360208301886137d1565b61429060408301876136c3565b61429d60608301866141f8565b8181036101008301526142b0818561356d565b90506142c061012083018461402e565b979650505050505050565b60006142d6826137c1565b915063ffffffff82036142ec576142eb613e38565b5b600182019050919050565b60006143028261326b565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361433457614333613e38565b5b600182019050919050565b60006020828403121561435557614354613203565b5b600061436384828501613c24565b91505092915050565b614375816137c1565b82525050565b606082016000820151614391600085018261436c565b5060208201516143a46020850182613fce565b5060408201516143b760408501826141e9565b50505050565b60006080820190506143d2600083018561437b565b6143df60608301846141cb565b9392505050565b600060a0820190506143fb60008301876141cb565b61440860208301866137d1565b61441560408301856136c3565b614422606083018461402e565b95945050505050565b7f41756374696f6e206973206e6f7420736574746c656400000000000000000000600082015250565b6000614461601683613cbd565b915061446c8261442b565b602082019050919050565b6000602082019050818103600083015261449081614454565b9050919050565b7f4f6e6c792077696e6e65722063616e20636c61696d20746f6b656e0000000000600082015250565b60006144cd601b83613cbd565b91506144d882614497565b602082019050919050565b600060208201905081810360008301526144fc816144c0565b9050919050565b600060208201905061451860008301846137a3565b92915050565b600061453161452c846139c9565b61342d565b90508281526020810184848401111561454d5761454c6139c4565b5b61455884828561353a565b509392505050565b600082601f830112614575576145746139bf565b5b815161458584826020860161451e565b91505092915050565b6000602082840312156145a4576145a3613203565b5b600082015167ffffffffffffffff8111156145c2576145c1613208565b5b6145ce84828501614560565b91505092915050565b600067ffffffffffffffff8211156145f2576145f16133cd565b5b6145fb826133bc565b9050602081019050919050565b600061461b614616846145d7565b61342d565b905082815260208101848484011115614637576146366139c4565b5b61464284828561353a565b509392505050565b600082601f83011261465f5761465e6139bf565b5b815161466f848260208601614608565b91505092915050565b60006020828403121561468e5761468d613203565b5b600082015167ffffffffffffffff8111156146ac576146ab613208565b5b6146b88482850161464a565b91505092915050565b600081519050919050565b60006146d7826146c1565b6146e18185613cbd565b93506146f181856020860161353a565b6146fa816133bc565b840191505092915050565b6000602082019050818103600083015261471f81846146cc565b905092915050565b6000819050919050565b6000819050919050565b600061475661475161474c84614727565b614731565b61332a565b9050919050565b6147668161473b565b82525050565b6000602082019050614781600083018461475d565b92915050565b600060808201905061479c60008301876137a3565b6147a960208301866137a3565b6147b660408301856136c3565b81810360608301526147c8818461356d565b905095945050505050565b600060e0820190506147e860008301866137d1565b6147f560208301856141f8565b81810360c0830152614807818461356d565b9050949350505050565b7f416c726561647920696e697469616c697a656400000000000000000000000000600082015250565b6000614847601383613cbd565b915061485282614811565b602082019050919050565b600060208201905081810360008301526148768161483a565b9050919050565b600081905092915050565b60006148938261351e565b61489d818561487d565b93506148ad81856020860161353a565b80840191505092915050565b60006148c58284614888565b915081905092915050565b7f496e697469616c697a6174696f6e206f6620436f6e666964656e7469616c436f60008201527f6e74726f6c206661696c65640000000000000000000000000000000000000000602082015250565b600061492c602c83613cbd565b9150614937826148d0565b604082019050919050565b6000602082019050818103600083015261495b8161491f565b9050919050565b7f4f6e6c792061756374696f6e206d61737465722063616e2063616e63656c0000600082015250565b6000614998601e83613cbd565b91506149a382614962565b602082019050919050565b600060208201905081810360008301526149c78161498b565b9050919050565b6000815190506149dd816135d2565b92915050565b6000602082840312156149f9576149f8613203565b5b6000614a07848285016149ce565b91505092915050565b6000604082019050614a2560008301856137b2565b614a3260208301846137a3565b9392505050565b6000614a448261326b565b9150614a4f8361326b565b925082821015614a6257614a61613e38565b5b828203905092915050565b6000606082019050614a8260008301866136c3565b614a8f60208301856137e0565b614a9c60408301846137e0565b949350505050565b50565b6000614ab460008361487d565b9150614abf82614aa4565b600082019050919050565b6000614ad582614aa7565b9150819050919050565b6000604082019050614af460008301856136c3565b8181036020830152614b06818461356d565b90509392505050565b6000614b1a8261326b565b9150614b258361326b565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115614b5a57614b59613e38565b5b828201905092915050565b6000602082019050614b7a60008301846141cb565b92915050565b600067ffffffffffffffff821115614b9b57614b9a6133cd565b5b602082029050602081019050919050565b600080fd5b600081519050614bc08161387c565b92915050565b600081519050614bd58161323f565b92915050565b600060608284031215614bf157614bf06133b7565b5b614bfb606061342d565b90506000614c0b84828501614bb1565b6000830152506020614c1f84828501614bc6565b6020830152506040614c3384828501613c24565b60408301525092915050565b6000614c52614c4d84614b80565b61342d565b90508083825260208201905060608402830185811115614c7557614c74614bac565b5b835b81811015614c9e5780614c8a8882614bdb565b845260208401935050606081019050614c77565b5050509392505050565b600082601f830112614cbd57614cbc6139bf565b5b8151614ccd848260208601614c3f565b91505092915050565b600060208284031215614cec57614ceb613203565b5b600082015167ffffffffffffffff811115614d0a57614d09613208565b5b614d1684828501614ca8565b91505092915050565b600060a082019050614d3460008301846141f8565b92915050565b6000819050919050565b614d55614d50826135c8565b614d3a565b82525050565b6000614d678284614d44565b60208201915081905092915050565b6000602082019050614d8b60008301846137b2565b92915050565b6000614d9c8261332a565b9150614da78361332a565b92508261ffff03821115614dbe57614dbd613e38565b5b828201905092915050565b6000604082019050614dde60008301856137a3565b614deb60208301846141cb565b9392505050565b60028110614e0357614e0261371a565b5b50565b6000819050614e1482614df2565b919050565b6000614e2482614e06565b9050919050565b614e3481614e19565b82525050565b6000602082019050614e4f6000830184614e2b565b92915050565b7f796f000000000000000000000000000000000000000000000000000000000000600082015250565b6000614e8b600283613cbd565b9150614e9682614e55565b602082019050919050565b60006020820190508181036000830152614eba81614e7e565b9050919050565b600060ff82169050919050565b614ed781614ec1565b82525050565b6000602082019050614ef26000830184614ece565b92915050565b60006060820190508181036000830152614f12818661356d565b9050614f216020830185614e2b565b8181036040830152614f3381846146cc565b9050949350505050565b6000608082019050614f5260008301876137b2565b614f5f6020830186614ece565b614f6c60408301856137b2565b614f7960608301846137b2565b95945050505050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000614fba8383613fce565b60208301905092915050565b6000602082019050919050565b6000614fde82614f82565b614fe88185614f8d565b9350614ff383614f9e565b8060005b8381101561502457815161500b8882614fae565b975061501683614fc6565b925050600181019050614ff7565b5085935050505092915050565b600060808201905061504660008301876137e0565b81810360208301526150588186614fd3565b9050818103604083015261506c8185614fd3565b9050818103606083015261508081846146cc565b905095945050505050565b600067ffffffffffffffff8211156150a6576150a56133cd565b5b602082029050602081019050919050565b60006150ca6150c58461508b565b61342d565b905080838252602082019050602084028301858111156150ed576150ec614bac565b5b835b8181101561511657806151028882614bc6565b8452602084019350506020810190506150ef565b5050509392505050565b600082601f830112615135576151346139bf565b5b81516151458482602086016150b7565b91505092915050565b600060c08284031215615164576151636133b7565b5b61516e60c061342d565b9050600061517e84828501613f7d565b600083015250602061519284828501613f7d565b60208301525060406151a684828501613c39565b604083015250606082015167ffffffffffffffff8111156151ca576151c9613448565b5b6151d684828501615120565b606083015250608082015167ffffffffffffffff8111156151fa576151f9613448565b5b61520684828501615120565b60808301525060a082015167ffffffffffffffff81111561522a57615229613448565b5b6152368482850161464a565b60a08301525092915050565b60006020828403121561525857615257613203565b5b600082015167ffffffffffffffff81111561527657615275613208565b5b6152828482850161514e565b91505092915050565b60006060820190506152a060008301866137a3565b81810360208301526152b281856146cc565b905081810360408301526152c6818461356d565b9050949350505050565b6152d98161326b565b82525050565b60006040820190506152f460008301856137b2565b61530160208301846152d0565b9392505050565b7f696e76616c6964207369676e6174757265206c656e6774680000000000000000600082015250565b600061533e601883613cbd565b915061534982615308565b602082019050919050565b6000602082019050818103600083015261536d81615331565b9050919050565b600061537f82614ec1565b915061538a83614ec1565b92508260ff038211156153a05761539f613e38565b5b828201905092915050565b60006040820190506153c060008301856137a3565b81810360208301526153d281846146cc565b9050939250505056fea2646970667358221220abef89796bef41344cf8ef8b2f71e4e04ed410da28fe796bb847f64fe30a261664736f6c634300080d00336080604052604051806020016040528073c8df3686b4afb2bb53e60eae97ef043fe03fb82973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152506000906001620000659291906200007a565b503480156200007357600080fd5b5062000128565b828054828255906000526020600020908101928215620000f6579160200282015b82811115620000f55782518260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550916020019190600101906200009b565b5b50905062000105919062000109565b5090565b5b80821115620001245760008160009055506001016200010a565b5090565b61252a80620001386000396000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c80637891d72f116100665780637891d72f1461016b578063986d666f1461019b578063b8106b56146101cb578063e596febd146101fb578063f06d34501461022b5761009e565b80631b5095ef146100a357806342bef59b146100bf5780634faac5af146100db5780634fb6aefa1461010b57806377e97ad61461013b575b600080fd5b6100bd60048036038101906100b8919061151b565b61025b565b005b6100d960048036038101906100d49190611725565b6102be565b005b6100f560048036038101906100f0919061181f565b6105ad565b6040516101029190611889565b60405180910390f35b610125600480360381019061012091906118a4565b610894565b6040516101329190611889565b60405180910390f35b610155600480360381019061015091906118d1565b610a8f565b604051610162919061190d565b60405180910390f35b61018560048036038101906101809190611928565b610ace565b60405161019291906119dd565b60405180910390f35b6101b560048036038101906101b09190611928565b610b1c565b6040516101c29190611a54565b60405180910390f35b6101e560048036038101906101e0919061181f565b610b64565b6040516101f29190611889565b60405180910390f35b61021560048036038101906102109190611928565b610e4b565b6040516102229190611a85565b60405180910390f35b610245600480360381019061024091906118a4565b610eab565b6040516102529190611bbe565b60405180910390f35b6102ba826040518060400160405280601381526020017f61756374696f6e3a76303a626964636f756e7400000000000000000000000000815250836040516020016102a69190611a85565b604051602081830303815290604052611000565b5050565b60006040518060400160405280600f81526020017f61756374696f6e3a76303a62696473000000000000000000000000000000000081525082604051602001610308929190611c52565b60405160208183030381529060405290506000600367ffffffffffffffff81111561033657610335611571565b5b6040519080825280602002602001820160405280156103645781602001602082028036833780820191505090505b509050308160008151811061037c5761037b611c7a565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506342030001816001815181106103cf576103ce611c7a565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420200018160028151811061042257610421611c7a565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505060006105766000808054806020026020016040519081016040528092919081815260200182805480156104e457602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001906001019080831161049a575b5050505050600080548060200260200160405190810160405280929190818152602001828054801561056b57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311610521575b5050505050866110e5565b90506105a6816000015184876040516020016105929190611ceb565b604051602081830303815290604052611000565b5050505050565b600080600367ffffffffffffffff8111156105cb576105ca611571565b5b6040519080825280602002602001820160405280156105f95781602001602082028036833780820191505090505b509050308160008151811061061157610610611c7a565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420300018160018151811061066457610663611c7a565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506342020001816002815181106106b7576106b6611c7a565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050600061084060008080548060200260200160405190810160405280929190818152602001828054801561077957602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001906001019080831161072f575b5050505050600080548060200260200160405190810160405280929190818152602001828054801561080057602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116107b6575b50505050506040518060400160405280601381526020017f61756374696f6e3a76303a706b736563726574000000000000000000000000008152506110e5565b905061088681600001516040518060400160405280601381526020017f61756374696f6e3a76303a706b7365637265740000000000000000000000000081525086611000565b806000015192505050919050565b600080600367ffffffffffffffff8111156108b2576108b1611571565b5b6040519080825280602002602001820160405280156108e05781602001602082028036833780820191505090505b50905030816000815181106108f8576108f7611c7a565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420300018160018151811061094b5761094a611c7a565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420200018160028151811061099e5761099d611c7a565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506000610a1c600083846040518060400160405280601381526020017f61756374696f6e3a76303a626964636f756e74000000000000000000000000008152506110e5565b9050610a8181600001516040518060400160405280601381526020017f61756374696f6e3a76303a626964636f756e740000000000000000000000000081525086604051602001610a6d9190611a85565b604051602081830303815290604052611000565b806000015192505050919050565b60008181548110610a9f57600080fd5b906000526020600020016000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60606000610b11836040518060400160405280601381526020017f61756374696f6e3a76303a706b736563726574000000000000000000000000008152506111ed565b905080915050919050565b6060610b5d826040518060400160405280601081526020017f61756374696f6e3a76303a746f6b656e000000000000000000000000000000008152506111ed565b9050919050565b600080600367ffffffffffffffff811115610b8257610b81611571565b5b604051908082528060200260200182016040528015610bb05781602001602082028036833780820191505090505b5090503081600081518110610bc857610bc7611c7a565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050634203000181600181518110610c1b57610c1a611c7a565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050634202000181600281518110610c6e57610c6d611c7a565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506000610df7600080805480602002602001604051908101604052809291908181526020018280548015610d3057602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311610ce6575b50505050506000805480602002602001604051908101604052809291908181526020018280548015610db757602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311610d6d575b50505050506040518060400160405280601081526020017f61756374696f6e3a76303a746f6b656e000000000000000000000000000000008152506110e5565b9050610e3d81600001516040518060400160405280601081526020017f61756374696f6e3a76303a746f6b656e0000000000000000000000000000000081525086611000565b806000015192505050919050565b600080610e8d836040518060400160405280601381526020017f61756374696f6e3a76303a626964636f756e74000000000000000000000000008152506111ed565b905080806020019051810190610ea39190611d1b565b915050919050565b606060006040518060400160405280600f81526020017f61756374696f6e3a76303a62696473000000000000000000000000000000000081525083604051602001610ef7929190611c52565b60405160208183030381529060405290506000610f156000836112d6565b90506000815167ffffffffffffffff811115610f3457610f33611571565b5b604051908082528060200260200182016040528015610f6d57816020015b610f5a6113d2565b815260200190600190039081610f525790505b50905060005b8251811015610ff4576000610fa6848381518110610f9457610f93611c7a565b5b602002602001015160000151866111ed565b9050600081806020019051810190610fbe9190611deb565b905080848481518110610fd457610fd3611c7a565b5b602002602001018190525050508080610fec90611e47565b915050610f73565b50809350505050919050565b600080634202000073ffffffffffffffffffffffffffffffffffffffff1685858560405160200161103393929190611e8f565b60405160208183030381529060405260405161104f9190611f10565b6000604051808303816000865af19150503d806000811461108c576040519150601f19603f3d011682016040523d82523d6000602084013e611091565b606091505b5091509150816110de576342020000816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016110d5929190611f27565b60405180910390fd5b5050505050565b6110ed61140f565b600080634203000073ffffffffffffffffffffffffffffffffffffffff16878787876040516020016111229493929190612029565b60405160208183030381529060405260405161113e9190611f10565b6000604051808303816000865af19150503d806000811461117b576040519150601f19603f3d011682016040523d82523d6000602084013e611180565b606091505b5091509150816111cd576342030000816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016111c4929190611f27565b60405180910390fd5b808060200190518101906111e19190612321565b92505050949350505050565b6060600080634202000173ffffffffffffffffffffffffffffffffffffffff16858560405160200161122092919061236a565b60405160208183030381529060405260405161123c9190611f10565b6000604051808303816000865af19150503d8060008114611279576040519150601f19603f3d011682016040523d82523d6000602084013e61127e565b606091505b5091509150816112cb576342020001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016112c2929190611f27565b60405180910390fd5b809250505092915050565b6060600080634203000173ffffffffffffffffffffffffffffffffffffffff16858560405160200161130992919061239a565b6040516020818303038152906040526040516113259190611f10565b6000604051808303816000865af19150503d8060008114611362576040519150601f19603f3d011682016040523d82523d6000602084013e611367565b606091505b5091509150816113b4576342030001816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016113ab929190611f27565b60405180910390fd5b808060200190518101906113c891906124ab565b9250505092915050565b6040518060600160405280600063ffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600081525090565b6040518060c0016040528060006fffffffffffffffffffffffffffffffff1916815260200160006fffffffffffffffffffffffffffffffff19168152602001600067ffffffffffffffff1681526020016060815260200160608152602001606081525090565b6000604051905090565b600080fd5b600080fd5b60007fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b6114be81611489565b81146114c957600080fd5b50565b6000813590506114db816114b5565b92915050565b600061ffff82169050919050565b6114f8816114e1565b811461150357600080fd5b50565b600081359050611515816114ef565b92915050565b600080604083850312156115325761153161147f565b5b6000611540858286016114cc565b925050602061155185828601611506565b9150509250929050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6115a982611560565b810181811067ffffffffffffffff821117156115c8576115c7611571565b5b80604052505050565b60006115db611475565b90506115e782826115a0565b919050565b600080fd5b600063ffffffff82169050919050565b61160a816115f1565b811461161557600080fd5b50565b60008135905061162781611601565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006116588261162d565b9050919050565b6116688161164d565b811461167357600080fd5b50565b6000813590506116858161165f565b92915050565b6000819050919050565b61169e8161168b565b81146116a957600080fd5b50565b6000813590506116bb81611695565b92915050565b6000606082840312156116d7576116d661155b565b5b6116e160606115d1565b905060006116f184828501611618565b600083015250602061170584828501611676565b6020830152506040611719848285016116ac565b60408301525092915050565b6000806080838503121561173c5761173b61147f565b5b600061174a858286016116c1565b925050606061175b85828601611506565b9150509250929050565b600080fd5b600080fd5b600067ffffffffffffffff82111561178a57611789611571565b5b61179382611560565b9050602081019050919050565b82818337600083830152505050565b60006117c26117bd8461176f565b6115d1565b9050828152602081018484840111156117de576117dd61176a565b5b6117e98482856117a0565b509392505050565b600082601f83011261180657611805611765565b5b81356118168482602086016117af565b91505092915050565b6000602082840312156118355761183461147f565b5b600082013567ffffffffffffffff81111561185357611852611484565b5b61185f848285016117f1565b91505092915050565b600061187382611489565b9050919050565b61188381611868565b82525050565b600060208201905061189e600083018461187a565b92915050565b6000602082840312156118ba576118b961147f565b5b60006118c884828501611506565b91505092915050565b6000602082840312156118e7576118e661147f565b5b60006118f5848285016116ac565b91505092915050565b6119078161164d565b82525050565b600060208201905061192260008301846118fe565b92915050565b60006020828403121561193e5761193d61147f565b5b600061194c848285016114cc565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561198f578082015181840152602081019050611974565b8381111561199e576000848401525b50505050565b60006119af82611955565b6119b98185611960565b93506119c9818560208601611971565b6119d281611560565b840191505092915050565b600060208201905081810360008301526119f781846119a4565b905092915050565b600081519050919050565b600082825260208201905092915050565b6000611a26826119ff565b611a308185611a0a565b9350611a40818560208601611971565b611a4981611560565b840191505092915050565b60006020820190508181036000830152611a6e8184611a1b565b905092915050565b611a7f816114e1565b82525050565b6000602082019050611a9a6000830184611a76565b92915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b611ad5816115f1565b82525050565b611ae48161164d565b82525050565b611af38161168b565b82525050565b606082016000820151611b0f6000850182611acc565b506020820151611b226020850182611adb565b506040820151611b356040850182611aea565b50505050565b6000611b478383611af9565b60608301905092915050565b6000602082019050919050565b6000611b6b82611aa0565b611b758185611aab565b9350611b8083611abc565b8060005b83811015611bb1578151611b988882611b3b565b9750611ba383611b53565b925050600181019050611b84565b5085935050505092915050565b60006020820190508181036000830152611bd88184611b60565b905092915050565b600081905092915050565b6000611bf682611955565b611c008185611be0565b9350611c10818560208601611971565b80840191505092915050565b60008160f01b9050919050565b6000611c3482611c1c565b9050919050565b611c4c611c47826114e1565b611c29565b82525050565b6000611c5e8285611beb565b9150611c6a8284611c3b565b6002820191508190509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b606082016000820151611cbf6000850182611acc565b506020820151611cd26020850182611adb565b506040820151611ce56040850182611aea565b50505050565b6000606082019050611d006000830184611ca9565b92915050565b600081519050611d15816114ef565b92915050565b600060208284031215611d3157611d3061147f565b5b6000611d3f84828501611d06565b91505092915050565b600081519050611d5781611601565b92915050565b600081519050611d6c8161165f565b92915050565b600081519050611d8181611695565b92915050565b600060608284031215611d9d57611d9c61155b565b5b611da760606115d1565b90506000611db784828501611d48565b6000830152506020611dcb84828501611d5d565b6020830152506040611ddf84828501611d72565b60408301525092915050565b600060608284031215611e0157611e0061147f565b5b6000611e0f84828501611d87565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611e528261168b565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611e8457611e83611e18565b5b600182019050919050565b6000606082019050611ea4600083018661187a565b8181036020830152611eb681856119a4565b90508181036040830152611eca8184611a1b565b9050949350505050565b600081905092915050565b6000611eea826119ff565b611ef48185611ed4565b9350611f04818560208601611971565b80840191505092915050565b6000611f1c8284611edf565b915081905092915050565b6000604082019050611f3c60008301856118fe565b8181036020830152611f4e8184611a1b565b90509392505050565b600067ffffffffffffffff82169050919050565b611f7481611f57565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000611fb28383611adb565b60208301905092915050565b6000602082019050919050565b6000611fd682611f7a565b611fe08185611f85565b9350611feb83611f96565b8060005b8381101561201c5781516120038882611fa6565b975061200e83611fbe565b925050600181019050611fef565b5085935050505092915050565b600060808201905061203e6000830187611f6b565b81810360208301526120508186611fcb565b905081810360408301526120648185611fcb565b9050818103606083015261207881846119a4565b905095945050505050565b600081519050612092816114b5565b92915050565b6120a181611f57565b81146120ac57600080fd5b50565b6000815190506120be81612098565b92915050565b600067ffffffffffffffff8211156120df576120de611571565b5b602082029050602081019050919050565b600080fd5b6000612108612103846120c4565b6115d1565b9050808382526020820190506020840283018581111561212b5761212a6120f0565b5b835b8181101561215457806121408882611d5d565b84526020840193505060208101905061212d565b5050509392505050565b600082601f83011261217357612172611765565b5b81516121838482602086016120f5565b91505092915050565b600067ffffffffffffffff8211156121a7576121a6611571565b5b6121b082611560565b9050602081019050919050565b60006121d06121cb8461218c565b6115d1565b9050828152602081018484840111156121ec576121eb61176a565b5b6121f7848285611971565b509392505050565b600082601f83011261221457612213611765565b5b81516122248482602086016121bd565b91505092915050565b600060c082840312156122435761224261155b565b5b61224d60c06115d1565b9050600061225d84828501612083565b600083015250602061227184828501612083565b6020830152506040612285848285016120af565b604083015250606082015167ffffffffffffffff8111156122a9576122a86115ec565b5b6122b58482850161215e565b606083015250608082015167ffffffffffffffff8111156122d9576122d86115ec565b5b6122e58482850161215e565b60808301525060a082015167ffffffffffffffff811115612309576123086115ec565b5b612315848285016121ff565b60a08301525092915050565b6000602082840312156123375761233661147f565b5b600082015167ffffffffffffffff81111561235557612354611484565b5b6123618482850161222d565b91505092915050565b600060408201905061237f600083018561187a565b818103602083015261239181846119a4565b90509392505050565b60006040820190506123af6000830185611f6b565b81810360208301526123c181846119a4565b90509392505050565b600067ffffffffffffffff8211156123e5576123e4611571565b5b602082029050602081019050919050565b6000612409612404846123ca565b6115d1565b9050808382526020820190506020840283018581111561242c5761242b6120f0565b5b835b8181101561247357805167ffffffffffffffff81111561245157612450611765565b5b80860161245e898261222d565b8552602085019450505060208101905061242e565b5050509392505050565b600082601f83011261249257612491611765565b5b81516124a28482602086016123f6565b91505092915050565b6000602082840312156124c1576124c061147f565b5b600082015167ffffffffffffffff8111156124df576124de611484565b5b6124eb8482850161247d565b9150509291505056fea2646970667358221220b79548a0006754bb3d1e511722df5c8c8f21b18078abccbe84ac04e0a755b0ef64736f6c634300080d0033608060405234801561001057600080fd5b5060405162003bba38038062003bba833981810160405281019061003491906102d9565b81604051610041906100ef565b61004b919061038a565b604051809103906000f080158015610067573d6000803e3d6000fd5b506000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050506103ac565b613459806200076183390190565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6101648261011b565b810181811067ffffffffffffffff821117156101835761018261012c565b5b80604052505050565b60006101966100fd565b90506101a2828261015b565b919050565b600067ffffffffffffffff8211156101c2576101c161012c565b5b6101cb8261011b565b9050602081019050919050565b60005b838110156101f65780820151818401526020810190506101db565b83811115610205576000848401525b50505050565b600061021e610219846101a7565b61018c565b90508281526020810184848401111561023a57610239610116565b5b6102458482856101d8565b509392505050565b600082601f83011261026257610261610111565b5b815161027284826020860161020b565b91505092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006102a68261027b565b9050919050565b6102b68161029b565b81146102c157600080fd5b50565b6000815190506102d3816102ad565b92915050565b600080604083850312156102f0576102ef610107565b5b600083015167ffffffffffffffff81111561030e5761030d61010c565b5b61031a8582860161024d565b925050602061032b858286016102c4565b9150509250929050565b600081519050919050565b600082825260208201905092915050565b600061035c82610335565b6103668185610340565b93506103768185602086016101d8565b61037f8161011b565b840191505092915050565b600060208201905081810360008301526103a48184610351565b905092915050565b6103a580620003bc6000396000f3fe608060405234801561001057600080fd5b5060008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631b8b921d600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166000366040518463ffffffff1660e01b815260040161009493929190610187565b6000604051808303816000875af11580156100b3573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906100dc9190610326565b90508081518060208301f35b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610113826100e8565b9050919050565b61012381610108565b82525050565b600082825260208201905092915050565b82818337600083830152505050565b6000601f19601f8301169050919050565b60006101668385610129565b935061017383858461013a565b61017c83610149565b840190509392505050565b600060408201905061019c600083018661011a565b81810360208301526101af81848661015a565b9050949350505050565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61020f82610149565b810181811067ffffffffffffffff8211171561022e5761022d6101d7565b5b80604052505050565b60006102416101b9565b905061024d8282610206565b919050565b600067ffffffffffffffff82111561026d5761026c6101d7565b5b61027682610149565b9050602081019050919050565b60005b838110156102a1578082015181840152602081019050610286565b838111156102b0576000848401525b50505050565b60006102c96102c484610252565b610237565b9050828152602081018484840111156102e5576102e46101d2565b5b6102f0848285610283565b509392505050565b600082601f83011261030d5761030c6101cd565b5b815161031d8482602086016102b6565b91505092915050565b60006020828403121561033c5761033b6101c3565b5b600082015167ffffffffffffffff81111561035a576103596101c8565b5b610366848285016102f8565b9150509291505056fea2646970667358221220ab9ca5c3cd5eaebca5d07af81685b3b73f2fefbfb3f2461a31f9e5f3a74fde9264736f6c634300080d003360806040523480156200001157600080fd5b5060405162003459380380620034598339818101604052810190620000379190620002a4565b80600090805190602001906200004f92919062000057565b505062000359565b828054620000659062000324565b90600052602060002090601f016020900481019282620000895760008555620000d5565b82601f10620000a457805160ff1916838001178555620000d5565b82800160010185558215620000d5579182015b82811115620000d4578251825591602001919060010190620000b7565b5b509050620000e49190620000e8565b5090565b5b8082111562000103576000816000905550600101620000e9565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b620001708262000125565b810181811067ffffffffffffffff8211171562000192576200019162000136565b5b80604052505050565b6000620001a762000107565b9050620001b5828262000165565b919050565b600067ffffffffffffffff821115620001d857620001d762000136565b5b620001e38262000125565b9050602081019050919050565b60005b8381101562000210578082015181840152602081019050620001f3565b8381111562000220576000848401525b50505050565b60006200023d6200023784620001ba565b6200019b565b9050828152602081018484840111156200025c576200025b62000120565b5b62000269848285620001f0565b509392505050565b600082601f8301126200028957620002886200011b565b5b81516200029b84826020860162000226565b91505092915050565b600060208284031215620002bd57620002bc62000111565b5b600082015167ffffffffffffffff811115620002de57620002dd62000116565b5b620002ec8482850162000271565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b600060028204905060018216806200033d57607f821691505b602082108103620003535762000352620002f5565b5b50919050565b6130f080620003696000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80631b8b921d1461005c57806370ae92d21461008c5780637c52407c146100bc578063c672f9d6146100ec578063e3d670d71461011c575b600080fd5b61007660048036038101906100719190611e68565b61014c565b6040516100839190611f4c565b60405180910390f35b6100a660048036038101906100a19190611f6e565b6101ba565b6040516100b39190611fb4565b60405180910390f35b6100d660048036038101906100d1919061212b565b61021c565b6040516100e39190611f4c565b60405180910390f35b61010660048036038101906101019190612257565b610377565b60405161011391906122cb565b60405180910390f35b61013660048036038101906101319190611f6e565b61061c565b6040516101439190611fb4565b60405180910390f35b606060006101598461067e565b610162846106f8565b604051602001610173929190612437565b6040516020818303038152906040529050600061018f82610377565b905060006101ac6101a76101a28461071e565b610740565b61084b565b905080935050505092915050565b6000806101c68361067e565b6040516020016101d6919061253a565b604051602081830303815290604052905060006101f282610377565b9050600061020f61020a6102058461071e565b6109cf565b610c01565b9050809350505050919050565b606060006102298561067e565b610232856106f8565b6040516020016102439291906125b3565b604051602081830303815290604052905060005b835181101561031d5781610288858381518110610277576102766125f8565b5b60200260200101516000015161067e565b6102af86848151811061029e5761029d6125f8565b5b6020026020010151602001516106f8565b6040516020016102c193929190612747565b6040516020818303038152906040529150600184516102e091906127c8565b81101561030a57816040516020016102f89190612848565b60405160208183030381529060405291505b80806103159061286a565b915050610257565b508060405160200161032f91906128fe565b6040516020818303038152906040529050600061034b82610377565b9050600061036861036361035e8461071e565b610740565b61084b565b90508093505050509392505050565b61037f611c5b565b610387611c6e565b6040518060400160405280600481526020017f504f5354000000000000000000000000000000000000000000000000000000008152508160200181905250600080546103d29061294f565b80601f01602080910402602001604051908101604052809291908181526020018280546103fe9061294f565b801561044b5780601f106104205761010080835404028352916020019161044b565b820191906000526020600020905b81548152906001019060200180831161042e57829003601f168201915b50505050508160000181905250600167ffffffffffffffff81111561047357610472611d3d565b5b6040519080825280602002602001820160405280156104a657816020015b60608152602001906001900390816104915790505b5081604001819052506040518060400160405280601e81526020017f436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e000081525081604001516000815181106104fd576104fc6125f8565b5b6020026020010181905250828160600181905250600061051c82610c9e565b9050600061052982610d97565b905060006105756040518060400160405280600781526020017f226572726f72220000000000000000000000000000000000000000000000000081525083610dc390919063ffffffff16565b905061058081610e46565b6105c95761058d8161071e565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105c091906129ca565b60405180910390fd5b6106116040518060400160405280600881526020017f22726573756c742200000000000000000000000000000000000000000000000081525083610dc390919063ffffffff16565b945050505050919050565b6000806106288361067e565b6040516020016106389190612a5e565b6040516020818303038152906040529050600061065482610377565b9050600061067161066c6106678461071e565b6109cf565b610c01565b9050809350505050919050565b606061068982610e5c565b905060ff6000190460061b60228201816022026028822016608860f01b60005b6001156106c85782811a820281820152600181019050601481036106a9575b50838351166000511660011c8351188352602083019250838351166020511660011c835118835250505050919050565b606061070382610e82565b90506002815101613078825260028203915080825250919050565b6060600061073561072e84610ef0565b6000610efa565b905080915050919050565b6060600082905060006004825161075791906127c8565b67ffffffffffffffff8111156107705761076f611d3d565b5b6040519080825280601f01601f1916602001820160405280156107a25781602001600182028036833780820191505090505b5090506000600390505b600183516107ba91906127c8565b811015610840578281815181106107d4576107d36125f8565b5b602001015160f81c60f81b826003836107ed91906127c8565b815181106107fe576107fd6125f8565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535080806108389061286a565b9150506107ac565b508092505050919050565b606060008290506000600282516108629190612aba565b1461086c57600080fd5b60006002825161087c9190612aeb565b67ffffffffffffffff81111561089557610894611d3d565b5b6040519080825280601f01601f1916602001820160405280156108c75781602001600182028036833780820191505090505b50905060005b600283516108db9190612aeb565b8110156109c4576109238360018360026108f59190612b1c565b6108ff9190612b76565b815181106109105761090f6125f8565b5b602001015160f81c60f81b60f81c6117be565b601061095a858460026109369190612b1c565b81518110610947576109466125f8565b5b602001015160f81c60f81b60f81c6117be565b6109649190612bd9565b61096e9190612c14565b60f81b828281518110610984576109836125f8565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350806109bd9061286a565b90506108cd565b508092505050919050565b606060008290506002815110158015610a4757507f220000000000000000000000000000000000000000000000000000000000000081600081518110610a1857610a176125f8565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b8015610abe57507f22000000000000000000000000000000000000000000000000000000000000008160018351610a7e91906127c8565b81518110610a8f57610a8e6125f8565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b610afd576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610af490612c97565b60405180910390fd5b600060028251610b0d91906127c8565b67ffffffffffffffff811115610b2657610b25611d3d565b5b6040519080825280601f01601f191660200182016040528015610b585781602001600182028036833780820191505090505b5090506000600190505b60018351610b7091906127c8565b811015610bf657828181518110610b8a57610b896125f8565b5b602001015160f81c60f81b82600183610ba391906127c8565b81518110610bb457610bb36125f8565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080610bee9061286a565b915050610b62565b508092505050919050565b600081516001811160208085015160f01c17613078141660011b5b600115610c84576001810190507403010a071000000b0104040208000c05090d060e0f6d03e4088843e41bac00000000000060ff83870151161c601f161a8360fc1c8115171583029250600181038460041b019350828210610c7e5750610c84565b50610c1c565b81610c975763101827966000526004601cfd5b5050919050565b6060600080634320000273ffffffffffffffffffffffffffffffffffffffff1684604051602001610ccf9190612ee9565b604051602081830303815290604052604051610ceb9190612f0b565b6000604051808303816000865af19150503d8060008114610d28576040519150601f19603f3d011682016040523d82523d6000602084013e610d2d565b606091505b509150915081610d7a576343200002816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401610d71929190612f31565b60405180910390fd5b80806020019051810190610d8e9190612fd1565b92505050919050565b610d9f611c5b565b806040526000610db8610db184611b63565b60ff610efa565b905080915050919050565b610dcb611c5b565b8060405260609050610ddc83611b6d565b15610e40576000828051906020012090506000610df885611b84565b9050600060058251901b90505b60008114610e3c5780820151955060208103905082610e2387611ba6565b8051906020012003610e3757859350610e3c565b610e05565b5050505b92915050565b60008060ff166007836000015116149050919050565b6060610e6782611bd8565b90506002815101613078825260028203915080825250919050565b60608151600260405101915080810182526f30313233343536373839616263646566600f52602082018184015b808514610edd57600185019450600f855116516001830153600f855160041c16518253600282019150610eaf565b6000825260208201604052505050919050565b6000819050919050565b6000611706565b63101827966000526004601cfd5b6000815160001a9050919050565b60008190505b600115610f4d576001640100002600610f3b83610f0f565b1c1615610f4e57600181019050610f23565b5b92915050565b600063ffffffff84113d3d3e83831b8263ffffffff851b19161790509392505050565b600081831c63ffffffff16905092915050565b60006040519050610faf8486036078610faa602086018803605888610f54565b610f54565b925085831781526020810160405295945050505050565b600080610fd7846018600051610f54565b610fe18787610f1d565b9150868210610ff05750611143565b610ff982610f0f565b600115611134576022810361102d578261101589858589611385565b935061102560048583868a610f8a565b945050611134565b605b810361104a576110418884848861114c565b93509350611134565b607b81036110675761105e88848488611224565b93509350611134565b6001611ff9602d1b821c161561108c5761108388848488611494565b93509350611134565b8760048401116110ef5782835160e01c637472756581036110c4576004850194506110bb60058684878b610f8a565b95505050611134565b636e756c6c81036110ec576004850194506110e360068684878b610f8a565b95505050611134565b50505b87600584011161112b5782835160d81c6466616c736581036111285760058501945061111f60058684878b610f8a565b95505050611134565b50505b611133610f01565b5b5061113f8783610f1d565b9150505b94509492505050565b60008060006001860191505b6001156111f65786821061116f5761116e610f01565b5b826111925761117e8783610f1d565b9150605d61118b83610f0f565b03156111f6575b61119e87838587610fc6565b9250925082156111e7576111b88160988551604017610f54565b83526001810190506111c982610f0f565b605d81036111d757506111f6565b602c81036111e557506111eb565b505b8691505b600182019150611158565b60018201915061120883603887610f54565b9450611218600183888888610f8a565b92505094509492505050565b6000806001850190505b6001156113175785811061124557611244610f01565b5b81611268576112548682610f1d565b9050607d61126182610f0f565b0315611317575b6112728682610f1d565b90508061128187838587611385565b61128b8882610f1d565b9250603a61129884610f0f565b03611306576112ac88600185018688610fc6565b935093508315611305576112d860208601830360986112d385850360b88951608017610f54565b610f54565b84526112e383610f0f565b607d81036112f357505050611317565b602c81036113035750505061130c565b505b5b87925050505b60018101905061122e565b60018101905061132982603886610f54565b9350611339600282878787610f8a565b915094509492505050565b6001667e0000007e03ff603061135b858501610f0f565b031c1661136b5761136a610f01565b5b60058214611381576113806001830182611344565b5b5050565b600084841061139757611396610f01565b5b6001840190505b600115611430576113ae81610f0f565b602281036113bc5750611430565b605c81146113d0576001820191505061142b565b6113dc60018301610f0f565b905060016a0510110400000000002001602283031c1615611403576002820191505061142b565b6075810361142257611416600283611344565b6006820191505061142b565b85915050611430565b61139e565b8481106114405761143f610f01565b5b600181019050949350505050565b60008190505b60011561147a57600a603061146883610f0f565b03101561147a57600181019050611454565b80821484161561148d5761148c610f01565b5b9392505050565b600080849050602d6114a582610f0f565b036114b1576001810190505b600a60306114be83610f0f565b03106114cd576114cc610f01565b5b6114d681610f0f565b600182019150603081146114f3576114f06000888461144e565b91505b602e6114fe83610f0f565b03611515576115126001886001850161144e565b91505b815160658160001a60201703611544576115416001896001860162010001600e8660011a031a0161144e565b92505b611552600384898989610f8a565b9350505094509492505050565b600060405190508282019150601f1980601f8601165b60011561158f578084015181840152818101905080611575575b50848252600085602084010152846040830101604052509392505050565b6000606090508151600281600716116116995782158115176116995760208116156115e4576115dd603882610f77565b9150611699565b6040519150602082016115f8603883610f77565b5b801561162d57808252805161160f601882610f77565b61161b87601884610f54565b835280925060208401935050506115f9565b50601f1983820381018060051c85528260405261164c85603886610f54565b93508360201786526040811061169557602085018186015b60011561169257815181518352808252848201915060208301925081831061168c5750611692565b50611664565b50505b5050505b50919050565b60006060905081518015831517156116b757506116fe565b6116c18482610f77565b91508086166116fc576116d560d882610f77565b6116e96116e28784610f77565b848361155f565b92506116f6838684610f54565b87178452505b505b949350505050565b816000811461177f576001811461179557600381146117ab5760208401845181018082146117645761173781610f0f565b6022825361174b8760d8602260f81b610f54565b60005261175b828460008a610fc6565b93509450808253505b8315818310171561177857611777610f01565b5b50506117b7565b61178e6010607860588761169f565b91506117b7565b6117a4600860b860988761169f565b91506117b7565b6117b4846115ad565b91505b5092915050565b60007f30000000000000000000000000000000000000000000000000000000000000007effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168260f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19161015801561189e57507f39000000000000000000000000000000000000000000000000000000000000007effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168260f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191611155b156118d9577f300000000000000000000000000000000000000000000000000000000000000060f81c826118d2919061301a565b9050611b5e565b7f61000000000000000000000000000000000000000000000000000000000000007effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168260f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916101580156119b757507f66000000000000000000000000000000000000000000000000000000000000007effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168260f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191611155b156119fe577f610000000000000000000000000000000000000000000000000000000000000060f81c82600a6119ed9190612c14565b6119f7919061301a565b9050611b5e565b7f41000000000000000000000000000000000000000000000000000000000000007effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168260f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191610158015611adc57507f46000000000000000000000000000000000000000000000000000000000000007effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168260f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191611155b15611b23577f410000000000000000000000000000000000000000000000000000000000000060f81c82600a611b129190612c14565b611b1c919061301a565b9050611b5e565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611b559061309a565b60405180910390fd5b919050565b6000819050919050565b6000600260ff166007836000015116149050919050565b60606000611b9b611b9484610ef0565b6003610efa565b905080915050919050565b60606000608083600001511614611bd3576000611bcc611bc584610ef0565b6001610efa565b9050809150505b919050565b60606040519050608081016040526f30313233343536373839616263646566600f526002810190506028815260208101600060288201528260601b925060005b600115611c5457808101820184821a600f81165160018301538060041c51825360018301925060148303611c4d575050611c54565b5050611c18565b5050919050565b6040518060200160405280600081525090565b6040518060c0016040528060608152602001606081526020016060815260200160608152602001600015158152602001600067ffffffffffffffff1681525090565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611cef82611cc4565b9050919050565b611cff81611ce4565b8114611d0a57600080fd5b50565b600081359050611d1c81611cf6565b92915050565b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b611d7582611d2c565b810181811067ffffffffffffffff82111715611d9457611d93611d3d565b5b80604052505050565b6000611da7611cb0565b9050611db38282611d6c565b919050565b600067ffffffffffffffff821115611dd357611dd2611d3d565b5b611ddc82611d2c565b9050602081019050919050565b82818337600083830152505050565b6000611e0b611e0684611db8565b611d9d565b905082815260208101848484011115611e2757611e26611d27565b5b611e32848285611de9565b509392505050565b600082601f830112611e4f57611e4e611d22565b5b8135611e5f848260208601611df8565b91505092915050565b60008060408385031215611e7f57611e7e611cba565b5b6000611e8d85828601611d0d565b925050602083013567ffffffffffffffff811115611eae57611ead611cbf565b5b611eba85828601611e3a565b9150509250929050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611efe578082015181840152602081019050611ee3565b83811115611f0d576000848401525b50505050565b6000611f1e82611ec4565b611f288185611ecf565b9350611f38818560208601611ee0565b611f4181611d2c565b840191505092915050565b60006020820190508181036000830152611f668184611f13565b905092915050565b600060208284031215611f8457611f83611cba565b5b6000611f9284828501611d0d565b91505092915050565b6000819050919050565b611fae81611f9b565b82525050565b6000602082019050611fc96000830184611fa5565b92915050565b600067ffffffffffffffff821115611fea57611fe9611d3d565b5b602082029050602081019050919050565b600080fd5b600080fd5b600080fd5b6000604082840312156120205761201f612000565b5b61202a6040611d9d565b9050600061203a84828501611d0d565b600083015250602082013567ffffffffffffffff81111561205e5761205d612005565b5b61206a84828501611e3a565b60208301525092915050565b600061208961208484611fcf565b611d9d565b905080838252602082019050602084028301858111156120ac576120ab611ffb565b5b835b818110156120f357803567ffffffffffffffff8111156120d1576120d0611d22565b5b8086016120de898261200a565b855260208501945050506020810190506120ae565b5050509392505050565b600082601f83011261211257612111611d22565b5b8135612122848260208601612076565b91505092915050565b60008060006060848603121561214457612143611cba565b5b600061215286828701611d0d565b935050602084013567ffffffffffffffff81111561217357612172611cbf565b5b61217f86828701611e3a565b925050604084013567ffffffffffffffff8111156121a05761219f611cbf565b5b6121ac868287016120fd565b9150509250925092565b600067ffffffffffffffff8211156121d1576121d0611d3d565b5b6121da82611d2c565b9050602081019050919050565b60006121fa6121f5846121b6565b611d9d565b90508281526020810184848401111561221657612215611d27565b5b612221848285611de9565b509392505050565b600082601f83011261223e5761223d611d22565b5b813561224e8482602086016121e7565b91505092915050565b60006020828403121561226d5761226c611cba565b5b600082013567ffffffffffffffff81111561228b5761228a611cbf565b5b61229784828501612229565b91505092915050565b6122a981611f9b565b82525050565b6020820160008201516122c560008501826122a0565b50505050565b60006020820190506122e060008301846122af565b92915050565b600081905092915050565b7f7b226a736f6e727063223a22322e30222c226d6574686f64223a226574685f6360008201527f616c6c222c22706172616d73223a5b7b22746f223a2200000000000000000000602082015250565b600061234d6036836122e6565b9150612358826122f1565b603682019050919050565b600081519050919050565b600061237982612363565b61238381856122e6565b9350612393818560208601611ee0565b80840191505092915050565b7f222c2264617461223a2200000000000000000000000000000000000000000000600082015250565b60006123d5600a836122e6565b91506123e08261239f565b600a82019050919050565b7f227d2c226c6174657374225d2c226964223a317d000000000000000000000000600082015250565b60006124216014836122e6565b915061242c826123eb565b601482019050919050565b600061244282612340565b915061244e828561236e565b9150612459826123c8565b9150612465828461236e565b915061247082612414565b91508190509392505050565b7f7b226a736f6e727063223a22322e30222c226d6574686f64223a226574685f6760008201527f65745472616e73616374696f6e436f756e74222c22706172616d73223a5b2200602082015250565b60006124d8603f836122e6565b91506124e38261247c565b603f82019050919050565b7f222c226c6174657374225d2c226964223a317d00000000000000000000000000600082015250565b60006125246013836122e6565b915061252f826124ee565b601382019050919050565b6000612545826124cb565b9150612551828461236e565b915061255c82612517565b915081905092915050565b7f227d2c226c6174657374222c7b00000000000000000000000000000000000000600082015250565b600061259d600d836122e6565b91506125a882612567565b600d82019050919050565b60006125be82612340565b91506125ca828561236e565b91506125d5826123c8565b91506125e1828461236e565b91506125ec82612590565b91508190509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600081905092915050565b600061263d82611ec4565b6126478185612627565b9350612657818560208601611ee0565b80840191505092915050565b7f2200000000000000000000000000000000000000000000000000000000000000600082015250565b60006126996001836122e6565b91506126a482612663565b600182019050919050565b7f223a207b22636f6465223a202200000000000000000000000000000000000000600082015250565b60006126e5600d836122e6565b91506126f0826126af565b600d82019050919050565b7f227d000000000000000000000000000000000000000000000000000000000000600082015250565b60006127316002836122e6565b915061273c826126fb565b600282019050919050565b60006127538286612632565b915061275e8261268c565b915061276a828561236e565b9150612775826126d8565b9150612781828461236e565b915061278c82612724565b9150819050949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006127d382611f9b565b91506127de83611f9b565b9250828210156127f1576127f0612799565b5b828203905092915050565b7f2c00000000000000000000000000000000000000000000000000000000000000600082015250565b60006128326001836122e6565b915061283d826127fc565b600182019050919050565b60006128548284612632565b915061285f82612825565b915081905092915050565b600061287582611f9b565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036128a7576128a6612799565b5b600182019050919050565b7f7d5d2c226964223a317d00000000000000000000000000000000000000000000600082015250565b60006128e8600a836122e6565b91506128f3826128b2565b600a82019050919050565b600061290a8284612632565b9150612915826128db565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000600282049050600182168061296757607f821691505b60208210810361297a57612979612920565b5b50919050565b600082825260208201905092915050565b600061299c82612363565b6129a68185612980565b93506129b6818560208601611ee0565b6129bf81611d2c565b840191505092915050565b600060208201905081810360008301526129e48184612991565b905092915050565b7f7b226a736f6e727063223a22322e30222c226d6574686f64223a226574685f6760008201527f657442616c616e6365222c22706172616d73223a5b2200000000000000000000602082015250565b6000612a486036836122e6565b9150612a53826129ec565b603682019050919050565b6000612a6982612a3b565b9150612a75828461236e565b9150612a8082612517565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000612ac582611f9b565b9150612ad083611f9b565b925082612ae057612adf612a8b565b5b828206905092915050565b6000612af682611f9b565b9150612b0183611f9b565b925082612b1157612b10612a8b565b5b828204905092915050565b6000612b2782611f9b565b9150612b3283611f9b565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615612b6b57612b6a612799565b5b828202905092915050565b6000612b8182611f9b565b9150612b8c83611f9b565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115612bc157612bc0612799565b5b828201905092915050565b600060ff82169050919050565b6000612be482612bcc565b9150612bef83612bcc565b92508160ff0483118215151615612c0957612c08612799565b5b828202905092915050565b6000612c1f82612bcc565b9150612c2a83612bcc565b92508260ff03821115612c4057612c3f612799565b5b828201905092915050565b7f496e76616c696420696e70757400000000000000000000000000000000000000600082015250565b6000612c81600d83612980565b9150612c8c82612c4b565b602082019050919050565b60006020820190508181036000830152612cb081612c74565b9050919050565b600082825260208201905092915050565b6000612cd382612363565b612cdd8185612cb7565b9350612ced818560208601611ee0565b612cf681611d2c565b840191505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000612d398383612cc8565b905092915050565b6000602082019050919050565b6000612d5982612d01565b612d638185612d0c565b935083602082028501612d7585612d1d565b8060005b85811015612db15784840389528151612d928582612d2d565b9450612d9d83612d41565b925060208a01995050600181019050612d79565b50829750879550505050505092915050565b600082825260208201905092915050565b6000612ddf82611ec4565b612de98185612dc3565b9350612df9818560208601611ee0565b612e0281611d2c565b840191505092915050565b60008115159050919050565b612e2281612e0d565b82525050565b600067ffffffffffffffff82169050919050565b612e4581612e28565b82525050565b600060c0830160008301518482036000860152612e688282612cc8565b91505060208301518482036020860152612e828282612cc8565b91505060408301518482036040860152612e9c8282612d4e565b91505060608301518482036060860152612eb68282612dd4565b9150506080830151612ecb6080860182612e19565b5060a0830151612ede60a0860182612e3c565b508091505092915050565b60006020820190508181036000830152612f038184612e4b565b905092915050565b6000612f178284612632565b915081905092915050565b612f2b81611ce4565b82525050565b6000604082019050612f466000830185612f22565b8181036020830152612f588184611f13565b90509392505050565b6000612f74612f6f84611db8565b611d9d565b905082815260208101848484011115612f9057612f8f611d27565b5b612f9b848285611ee0565b509392505050565b600082601f830112612fb857612fb7611d22565b5b8151612fc8848260208601612f61565b91505092915050565b600060208284031215612fe757612fe6611cba565b5b600082015167ffffffffffffffff81111561300557613004611cbf565b5b61301184828501612fa3565b91505092915050565b600061302582612bcc565b915061303083612bcc565b92508282101561304357613042612799565b5b828203905092915050565b7f6661696c00000000000000000000000000000000000000000000000000000000600082015250565b6000613084600483612980565b915061308f8261304e565b602082019050919050565b600060208201905081810360008301526130b381613077565b905091905056fea26469706673582212204dadfc3dd7b06dfdfe2b4f230bd018ff4a7ae14b939f862a6b425e706648651f64736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061012f5760003560e01c8063617e3cb7116100ad57806396b5a7551161007157806396b5a7551461034a578063aad09be314610366578063c0631ea514610384578063da5cea8c146103a2578063fbfa77cf146103be57610130565b8063617e3cb7146102ba5780637e48532c146102d65780638528dbdf146102f457806389c438a2146103105780638c9043e61461032e57610130565b8063392e53cd116100f4578063392e53cd146101fa5780634ca89c2c14610218578063571a26a01461023657806357fcc1a51461026e5780635bbdb7561461028a57610130565b8062d23ce81461013257806309f73940146101625780631ed55ecc1461017e57806326d09ad5146101ae5780632f125731146101ca57610130565b5b005b61014c600480360381019061014791906132a1565b6103dc565b604051610159919061330f565b60405180910390f35b61017c60048036038101906101779190613364565b6104a7565b005b610198600480360381019061019391906134f1565b61068c565b6040516101a591906135a6565b60405180910390f35b6101c860048036038101906101c39190613656565b61086a565b005b6101e460048036038101906101df9190613696565b61092b565b6040516101f191906135a6565b60405180910390f35b610202610d59565b60405161020f919061330f565b60405180910390f35b610220610d6c565b60405161022d91906136d2565b60405180910390f35b610250600480360381019061024b91906136ed565b610d92565b604051610265999897969594939291906137ef565b60405180910390f35b610288600480360381019061028391906138cc565b610ea2565b005b6102a4600480360381019061029f9190613696565b610fcf565b6040516102b191906135a6565b60405180910390f35b6102d460048036038101906102cf9190613696565b611200565b005b6102de6114c9565b6040516102eb91906135a6565b60405180910390f35b61030e60048036038101906103099190613a79565b611708565b005b61031861185b565b60405161032591906136d2565b60405180910390f35b61034860048036038101906103439190613b25565b61187f565b005b610364600480360381019061035f91906136ed565b611abe565b005b61036e611c6d565b60405161037b91906135a6565b60405180910390f35b61038c611dba565b604051610399919061330f565b60405180910390f35b6103bc60048036038101906103b79190613ba8565b611dca565b005b6103c661202e565b6040516103d391906136d2565b60405180910390f35b6000806000600660019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f8b2cb4f876040518263ffffffff1660e01b815260040161043c91906136d2565b60408051808303816000875af115801561045a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061047e9190613c4e565b9150915084821015801561049c5750838167ffffffffffffffff1610155b925050509392505050565b600060058461ffff16815481106104c1576104c0613c8e565b5b90600052602060002090600602019050600060028111156104e5576104e461371a565b5b8160000160149054906101000a900460ff1660028111156105095761050861371a565b5b14610549576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161054090613d1a565b60405180910390fd5b8060030160049054906101000a900467ffffffffffffffff1667ffffffffffffffff164211156105ae576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105a590613d86565b60405180910390fd5b600082116105f1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105e890613e18565b60405180910390fd5b6000610643848484600301600c9054906101000a900467ffffffffffffffff168560030160049054906101000a900467ffffffffffffffff166106349190613e67565b67ffffffffffffffff166103dc565b905080610685576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161067c90613ef1565b60405180910390fd5b5050505050565b60606106d4610699612054565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c0000000000000000000000000000000081525061211e565b600660009054906101000a900460ff16610723576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161071a90613f5d565b60405180910390fd5b600061072d612164565b905060008180519060200120905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b8106b56846040518263ffffffff1660e01b815260040161079691906135a6565b6020604051808303816000875af11580156107b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d99190613f92565b905063da5cea8c60e01b858333846107ef6121a9565b60405160240161080395949392919061405d565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050509350505050919050565b6108f77f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600c81526020017f556e617574686f72697a6564000000000000000000000000000000000000000081525061211e565b81600181905550806000806101000a8154816fffffffffffffffffffffffffffffffff021916908360801c02179055505050565b6060610973610938612054565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c0000000000000000000000000000000081525061211e565b600660009054906101000a900460ff166109c2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109b990613f5d565b60405180910390fd5b600060058361ffff16815481106109dc576109db613c8e565b5b9060005260206000209060060201905060006002811115610a00576109ff61371a565b5b8160000160149054906101000a900460ff166002811115610a2457610a2361371a565b5b14610a64576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a5b90613d1a565b60405180910390fd5b8060030160049054906101000a900467ffffffffffffffff1667ffffffffffffffff164211610ac8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610abf906140fd565b60405180910390fd5b60008160030160009054906101000a900463ffffffff1663ffffffff1611610b25576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b1c90614169565b60405180910390fd5b600080610b31856121eb565b9150915060006040518060a00160405280600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018560000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600660019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663aa43ef568760000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b8152600401610c3f91906136d2565b6020604051808303816000875af1158015610c5e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c82919061419e565b61ffff168152602001846020015173ffffffffffffffffffffffffffffffffffffffff1681526020018381525090506000610cbc826122b0565b9050638528dbdf60e01b87856000015186602001518585610cdb6121a9565b604051602401610cf096959493929190614260565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505095505050505050919050565b600660009054906101000a900460ff1681565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60058181548110610da257600080fd5b90600052602060002090600602016000915090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060000160149054906101000a900460ff16908060010160009054906101000a900460801b908060020154908060030160009054906101000a900463ffffffff16908060030160049054906101000a900467ffffffffffffffff169080600301600c9054906101000a900467ffffffffffffffff16908060040160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060050160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905089565b80610eee610eb382600001356123c5565b6040518060400160405280600b81526020017f496e76616c6964206b657900000000000000000000000000000000000000000081525061211e565b60058561ffff1681548110610f0657610f05613c8e565b5b9060005260206000209060060201600301600081819054906101000a900463ffffffff1680929190610f37906142cb565b91906101000a81548163ffffffff021916908363ffffffff160217905550508273ffffffffffffffffffffffffffffffffffffffff168463ffffffff168661ffff167f5fcb419af364578136edb4adbd64aff3d15c2301b8a8a7af01d49f82f82dfcb860405160405180910390a4806020013560018190555060026000815480929190610fc3906142f7565b91905055505050505050565b6060611017610fdc612054565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c0000000000000000000000000000000081525061211e565b600660009054906101000a900460ff16611066576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161105d90613f5d565b60405180910390fd5b6000611070612164565b806020019051810190611083919061433f565b905060003390506110958482846104a7565b60006110a8856110a36123f9565b612553565b9050600060405180606001604052808363ffffffff1681526020018473ffffffffffffffffffffffffffffffffffffffff1681526020018581525090507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166342bef59b82886040518363ffffffff1660e01b81526004016111409291906143bd565b600060405180830381600087803b15801561115a57600080fd5b505af115801561116e573d6000803e3d6000fd5b505050506357fcc1a560e01b8683856111856121a9565b60405160240161119894939291906143e6565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050945050505050919050565b61124661120b612054565b6040518060400160405280601081526020017f4e6f7420636f6e666964656e7469616c0000000000000000000000000000000081525061211e565b600660009054906101000a900460ff16611295576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161128c90613f5d565b60405180910390fd5b600060058261ffff16815481106112af576112ae613c8e565b5b906000526020600020906006020190506002808111156112d2576112d161371a565b5b8160000160149054906101000a900460ff1660028111156112f6576112f561371a565b5b14611336576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161132d90614477565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff168160050160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146113c8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113bf906144e3565b60405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663986d666f8260010160009054906101000a900460801b6040518263ffffffff1660e01b81526004016114329190614503565b6000604051808303816000875af1158015611451573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061147a919061458e565b80602001905181019061148d9190614678565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114c09190614705565b60405180910390fd5b606061151a600660009054906101000a900460ff16156040518060400160405280601381526020017f416c726561647920696e697469616c697a65640000000000000000000000000081525061211e565b6000611526600061256c565b9050600061153382612665565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16634faac5af846040518263ffffffff1660e01b815260040161159091906135a6565b6020604051808303816000875af11580156115af573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115d39190613f92565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16634fb6aefa60006040518263ffffffff1660e01b8152600401611631919061476c565b6020604051808303816000875af1158015611650573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116749190613f92565b90506000611680611c6d565b9050638c9043e660e01b838386846040516024016116a19493929190614787565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050509550505050505090565b8061175461171982600001356123c5565b6040518060400160405280600b81526020017f496e76616c6964206b657900000000000000000000000000000000000000000081525061211e565b600060058861ffff168154811061176e5761176d613c8e565b5b9060005260206000209060060201905060028160000160146101000a81548160ff021916908360028111156117a6576117a561371a565b5b0217905550858160050160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508761ffff167f911af55ab638b0215837b0ab0ab963a9b439db2c329ebbf57e981edb1ee8cd4d888787604051611826939291906147d3565b60405180910390a25080602001356001819055506002600081548092919061184d906142f7565b919050555050505050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b61190c7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600c81526020017f556e617574686f72697a6564000000000000000000000000000000000000000081525061211e565b600660009054906101000a900460ff161561195c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016119539061485d565b60405180910390fd5b82600760106101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555083600760006101000a8154816fffffffffffffffffffffffffffffffff021916908360801c021790555081600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001600660006101000a81548160ff02191690831515021790555060003073ffffffffffffffffffffffffffffffffffffffff1682604051611a3391906148b9565b600060405180830381855af49150503d8060008114611a6e576040519150601f19603f3d011682016040523d82523d6000602084013e611a73565b606091505b5050905080611ab7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611aae90614942565b60405180910390fd5b5050505050565b600060058281548110611ad457611ad3613c8e565b5b906000526020600020906006020190503373ffffffffffffffffffffffffffffffffffffffff168160040160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614611b76576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611b6d906149ae565b60405180910390fd5b60006002811115611b8a57611b8961371a565b5b8160000160149054906101000a900460ff166002811115611bae57611bad61371a565b5b14611bee576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611be590613d1a565b60405180910390fd5b600160058381548110611c0457611c03613c8e565b5b906000526020600020906006020160000160146101000a81548160ff02191690836002811115611c3757611c3661371a565b5b0217905550817f2809c7e17bf978fbc7194c0a694b638c4215e9140cacc6c38ca36010b45697df60405160405180910390a25050565b6060611cfc7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600c81526020017f556e617574686f72697a6564000000000000000000000000000000000000000081525061211e565b6000611d0860206126d1565b90506000611d15826127ca565b90506000611d3883806020019051810190611d3091906149e3565b6002546129a6565b90506326d09ad560e01b8183604051602401611d55929190614a10565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050935050505090565b60008060001b6001541415905090565b80611e16611ddb82600001356123c5565b6040518060400160405280600b81526020017f496e76616c6964206b657900000000000000000000000000000000000000000081525061211e565b6000866000015142611e289190613e67565b905060006005600181600181540180825580915050039060005260206000209060060201905060008160000160146101000a81548160ff02191690836002811115611e7657611e7561371a565b5b021790555087604001518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550868160020181905550818160030160046101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550876020015181600301600c6101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550858160040160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550848160010160006101000a8154816fffffffffffffffffffffffffffffffff021916908360801c0217905550868673ffffffffffffffffffffffffffffffffffffffff166001600580549050611fbe9190614a39565b7f216b9e3e12e47255d565cd84569baa0c9998c971b9b8631c092eea22c8ed9e338b60400151868d60200151604051611ff993929190614a6d565b60405180910390a45050806020013560018190555060026000815480929190612021906142f7565b9190505550505050505050565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000806000634201000073ffffffffffffffffffffffffffffffffffffffff1660405161208090614aca565b6000604051808303816000865af19150503d80600081146120bd576040519150601f19603f3d011682016040523d82523d6000602084013e6120c2565b606091505b50915091508161210f576342010000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612106929190614adf565b60405180910390fd5b80516020820151935050505090565b8161216057806040517f0c25cd980000000000000000000000000000000000000000000000000000000081526004016121579190614705565b60405180910390fd5b5050565b60606121a46040518060400160405280601281526020017f636f6e666964656e7469616c496e7075747300000000000000000000000000008152506129e0565b905090565b6121b1613136565b60405180604001604052806121c7600254612ad9565b81526020016121e360016002546121de9190614b0f565b612af3565b815250905090565b6121f3613156565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f06d3450856040518263ffffffff1660e01b815260040161224f9190614b65565b6000604051808303816000875af115801561226e573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906122979190614cd6565b90506122a281612b2b565b809350819450505050915091565b606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16637891d72f600760009054906101000a900460801b6040518263ffffffff1660e01b815260040161231c9190614503565b6000604051808303816000875af115801561233b573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906123649190614678565b90506000836040516020016123799190614d1f565b6040516020818303038152906040528051906020012090506123bc816040516020016123a59190614d5b565b604051602081830303815290604052600084612bbf565b92505050919050565b6000600154826040516020016123db9190614d76565b60405160208183030381529060405280519060200120149050919050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663e596febd600760109054906101000a900460801b6040518263ffffffff1660e01b81526004016124639190614503565b6020604051808303816000875af1158015612482573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124a6919061419e565b90507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631b5095ef600760109054906101000a900460801b6001846125019190614d91565b6040518363ffffffff1660e01b815260040161251e929190614dc9565b600060405180830381600087803b15801561253857600080fd5b505af115801561254c573d6000803e3d6000fd5b5050505090565b60008160108461ffff16901b1761ffff16905092915050565b6060600080635320000373ffffffffffffffffffffffffffffffffffffffff168460405160200161259d9190614e3a565b6040516020818303038152906040526040516125b991906148b9565b6000604051808303816000865af19150503d80600081146125f6576040519150601f19603f3d011682016040523d82523d6000602084013e6125fb565b606091505b509150915081612648576353200003816040517f75fff46700000000000000000000000000000000000000000000000000000000815260040161263f929190614adf565b60405180910390fd5b8080602001905181019061265c9190614678565b92505050919050565b60008060405160200161267790614ea1565b60405160208183030381529060405280519060200120905060006126bc826040516020016126a59190614d5b565b604051602081830303815290604052600086612bbf565b90506126c88282612ccf565b92505050919050565b6060600080637770000b73ffffffffffffffffffffffffffffffffffffffff16846040516020016127029190614edd565b60405160208183030381529060405260405161271e91906148b9565b6000604051808303816000865af19150503d806000811461275b576040519150601f19603f3d011682016040523d82523d6000602084013e612760565b606091505b5091509150816127ad57637770000b816040517f75fff4670000000000000000000000000000000000000000000000000000000081526004016127a4929190614adf565b60405180910390fd5b808060200190518101906127c1919061458e565b92505050919050565b600080600367ffffffffffffffff8111156127e8576127e76133cd565b5b6040519080825280602002602001820160405280156128165781602001602082028036833780820191505090505b509050308160008151811061282e5761282d613c8e565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505063420300018160018151811061288157612880613c8e565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506342020001816002815181106128d4576128d3613c8e565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506000612952600083846040518060400160405280601181526020017f626c6f636b61643a76303a736563726574000000000000000000000000000000815250612d3e565b905061299881600001516040518060400160405280601181526020017f626c6f636b61643a76303a73656372657400000000000000000000000000000081525086612e46565b806000015192505050919050565b60006129b28383612f2b565b6040516020016129c29190614d76565b60405160208183030381529060405280519060200120905092915050565b6060600080635330000373ffffffffffffffffffffffffffffffffffffffff1684604051602001612a119190614705565b604051602081830303815290604052604051612a2d91906148b9565b6000604051808303816000865af19150503d8060008114612a6a576040519150601f19603f3d011682016040523d82523d6000602084013e612a6f565b606091505b509150915081612abc576353300003816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612ab3929190614adf565b60405180910390fd5b80806020019051810190612ad0919061458e565b92505050919050565b6000612aec612ae6612f5e565b83612f2b565b9050919050565b6000612afe82612ad9565b604051602001612b0e9190614d76565b604051602081830303815290604052805190602001209050919050565b612b33613156565b600080600090505b8351811015612ba9576000848281518110612b5957612b58613c8e565b5b60200260200101519050836040015181604001511115612b825783604001519250809350612b97565b8281604001511115612b9657806040015192505b5b5080612ba2906142f7565b9050612b3b565b5060008103612bba57816040015190505b915091565b6060612bc9612054565b612bd257600080fd5b600080634010000373ffffffffffffffffffffffffffffffffffffffff16868686604051602001612c0593929190614ef8565b604051602081830303815290604052604051612c2191906148b9565b6000604051808303816000865af19150503d8060008114612c5e576040519150601f19603f3d011682016040523d82523d6000602084013e612c63565b606091505b509150915081612cb0576340100003816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612ca7929190614adf565b60405180910390fd5b80806020019051810190612cc4919061458e565b925050509392505050565b600080600080612cde85612fc9565b92509250925060018682858560405160008152602001604052604051612d079493929190614f3d565b6020604051602081039080840390855afa158015612d29573d6000803e3d6000fd5b50505060206040510351935050505092915050565b612d46613193565b600080634203000073ffffffffffffffffffffffffffffffffffffffff1687878787604051602001612d7b9493929190615031565b604051602081830303815290604052604051612d9791906148b9565b6000604051808303816000865af19150503d8060008114612dd4576040519150601f19603f3d011682016040523d82523d6000602084013e612dd9565b606091505b509150915081612e26576342030000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612e1d929190614adf565b60405180910390fd5b80806020019051810190612e3a9190615242565b92505050949350505050565b600080634202000073ffffffffffffffffffffffffffffffffffffffff16858585604051602001612e799392919061528b565b604051602081830303815290604052604051612e9591906148b9565b6000604051808303816000865af19150503d8060008114612ed2576040519150601f19603f3d011682016040523d82523d6000602084013e612ed7565b606091505b509150915081612f24576342020000816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401612f1b929190614adf565b60405180910390fd5b5050505050565b60008282604051602001612f409291906152df565b60405160208183030381529060405280519060200120905092915050565b600080612fad60008054906101000a900460801b6040518060400160405280601181526020017f626c6f636b61643a76303a73656372657400000000000000000000000000000081525061304d565b905080806020019051810190612fc391906149e3565b91505090565b60008060006041845114613012576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161300990615354565b60405180910390fd5b6020840151925060408401519150606084015160001a9050601b8160ff16101561304657601b816130439190615374565b90505b9193909250565b6060600080634202000173ffffffffffffffffffffffffffffffffffffffff1685856040516020016130809291906153ab565b60405160208183030381529060405260405161309c91906148b9565b6000604051808303816000865af19150503d80600081146130d9576040519150601f19603f3d011682016040523d82523d6000602084013e6130de565b606091505b50915091508161312b576342020001816040517f75fff467000000000000000000000000000000000000000000000000000000008152600401613122929190614adf565b60405180910390fd5b809250505092915050565b604051806040016040528060008019168152602001600080191681525090565b6040518060600160405280600063ffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600081525090565b6040518060c0016040528060006fffffffffffffffffffffffffffffffff1916815260200160006fffffffffffffffffffffffffffffffff19168152602001600067ffffffffffffffff1681526020016060815260200160608152602001606081525090565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006132388261320d565b9050919050565b6132488161322d565b811461325357600080fd5b50565b6000813590506132658161323f565b92915050565b6000819050919050565b61327e8161326b565b811461328957600080fd5b50565b60008135905061329b81613275565b92915050565b6000806000606084860312156132ba576132b9613203565b5b60006132c886828701613256565b93505060206132d98682870161328c565b92505060406132ea8682870161328c565b9150509250925092565b60008115159050919050565b613309816132f4565b82525050565b60006020820190506133246000830184613300565b92915050565b600061ffff82169050919050565b6133418161332a565b811461334c57600080fd5b50565b60008135905061335e81613338565b92915050565b60008060006060848603121561337d5761337c613203565b5b600061338b8682870161334f565b935050602061339c86828701613256565b92505060406133ad8682870161328c565b9150509250925092565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b613405826133bc565b810181811067ffffffffffffffff82111715613424576134236133cd565b5b80604052505050565b60006134376131f9565b905061344382826133fc565b919050565b600080fd5b600067ffffffffffffffff82169050919050565b61346a8161344d565b811461347557600080fd5b50565b60008135905061348781613461565b92915050565b6000606082840312156134a3576134a26133b7565b5b6134ad606061342d565b905060006134bd84828501613478565b60008301525060206134d184828501613478565b60208301525060406134e584828501613256565b60408301525092915050565b60006060828403121561350757613506613203565b5b60006135158482850161348d565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561355857808201518184015260208101905061353d565b83811115613567576000848401525b50505050565b60006135788261351e565b6135828185613529565b935061359281856020860161353a565b61359b816133bc565b840191505092915050565b600060208201905081810360008301526135c0818461356d565b905092915050565b6000819050919050565b6135db816135c8565b81146135e657600080fd5b50565b6000813590506135f8816135d2565b92915050565b60007fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b613633816135fe565b811461363e57600080fd5b50565b6000813590506136508161362a565b92915050565b6000806040838503121561366d5761366c613203565b5b600061367b858286016135e9565b925050602061368c85828601613641565b9150509250929050565b6000602082840312156136ac576136ab613203565b5b60006136ba8482850161334f565b91505092915050565b6136cc8161322d565b82525050565b60006020820190506136e760008301846136c3565b92915050565b60006020828403121561370357613702613203565b5b60006137118482850161328c565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6003811061375a5761375961371a565b5b50565b600081905061376b82613749565b919050565b600061377b8261375d565b9050919050565b61378b81613770565b82525050565b600061379c826135fe565b9050919050565b6137ac81613791565b82525050565b6137bb816135c8565b82525050565b600063ffffffff82169050919050565b6137da816137c1565b82525050565b6137e98161344d565b82525050565b600061012082019050613805600083018c6136c3565b613812602083018b613782565b61381f604083018a6137a3565b61382c60608301896137b2565b61383960808301886137d1565b61384660a08301876137e0565b61385360c08301866137e0565b61386060e08301856136c3565b61386e6101008301846136c3565b9a9950505050505050505050565b613885816137c1565b811461389057600080fd5b50565b6000813590506138a28161387c565b92915050565b600080fd5b6000604082840312156138c3576138c26138a8565b5b81905092915050565b60008060008060a085870312156138e6576138e5613203565b5b60006138f48782880161334f565b945050602061390587828801613893565b935050604061391687828801613256565b9250506060613927878288016138ad565b91505092959194509250565b600060a08284031215613949576139486133b7565b5b61395360a061342d565b9050600061396384828501613256565b600083015250602061397784828501613256565b602083015250604061398b8482850161334f565b604083015250606061399f84828501613256565b60608301525060806139b38482850161328c565b60808301525092915050565b600080fd5b600080fd5b600067ffffffffffffffff8211156139e4576139e36133cd565b5b6139ed826133bc565b9050602081019050919050565b82818337600083830152505050565b6000613a1c613a17846139c9565b61342d565b905082815260208101848484011115613a3857613a376139c4565b5b613a438482856139fa565b509392505050565b600082601f830112613a6057613a5f6139bf565b5b8135613a70848260208601613a09565b91505092915050565b6000806000806000806101608789031215613a9757613a96613203565b5b6000613aa589828a0161334f565b9650506020613ab689828a01613893565b9550506040613ac789828a01613256565b9450506060613ad889828a01613933565b93505061010087013567ffffffffffffffff811115613afa57613af9613208565b5b613b0689828a01613a4b565b925050610120613b1889828a016138ad565b9150509295509295509295565b60008060008060808587031215613b3f57613b3e613203565b5b6000613b4d87828801613641565b9450506020613b5e87828801613641565b9350506040613b6f87828801613256565b925050606085013567ffffffffffffffff811115613b9057613b8f613208565b5b613b9c87828801613a4b565b91505092959194509250565b60008060008060006101008688031215613bc557613bc4613203565b5b6000613bd38882890161348d565b9550506060613be4888289016135e9565b9450506080613bf588828901613256565b93505060a0613c0688828901613641565b92505060c0613c17888289016138ad565b9150509295509295909350565b600081519050613c3381613275565b92915050565b600081519050613c4881613461565b92915050565b60008060408385031215613c6557613c64613203565b5b6000613c7385828601613c24565b9250506020613c8485828601613c39565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600082825260208201905092915050565b7f41756374696f6e206973206e6f74206c69766500000000000000000000000000600082015250565b6000613d04601383613cbd565b9150613d0f82613cce565b602082019050919050565b60006020820190508181036000830152613d3381613cf7565b9050919050565b7f41756374696f6e2068617320656e646564000000000000000000000000000000600082015250565b6000613d70601183613cbd565b9150613d7b82613d3a565b602082019050919050565b60006020820190508181036000830152613d9f81613d63565b9050919050565b7f42696420616d6f756e742073686f756c6420626520677265617465722074686160008201527f6e207a65726f0000000000000000000000000000000000000000000000000000602082015250565b6000613e02602683613cbd565b9150613e0d82613da6565b604082019050919050565b60006020820190508181036000830152613e3181613df5565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000613e728261344d565b9150613e7d8361344d565b92508267ffffffffffffffff03821115613e9a57613e99613e38565b5b828201905092915050565b7f496e73756666696369656e742066756e64730000000000000000000000000000600082015250565b6000613edb601283613cbd565b9150613ee682613ea5565b602082019050919050565b60006020820190508181036000830152613f0a81613ece565b9050919050565b7f4e6f7420696e697469616c697a65640000000000000000000000000000000000600082015250565b6000613f47600f83613cbd565b9150613f5282613f11565b602082019050919050565b60006020820190508181036000830152613f7681613f3a565b9050919050565b600081519050613f8c8161362a565b92915050565b600060208284031215613fa857613fa7613203565b5b6000613fb684828501613f7d565b91505092915050565b613fc88161344d565b82525050565b613fd78161322d565b82525050565b606082016000820151613ff36000850182613fbf565b5060208201516140066020850182613fbf565b5060408201516140196040850182613fce565b50505050565b614028816135c8565b82525050565b604082016000820151614044600085018261401f565b506020820151614057602085018261401f565b50505050565b6000610100820190506140736000830188613fdd565b61408060608301876137b2565b61408d60808301866136c3565b61409a60a08301856137a3565b6140a760c083018461402e565b9695505050505050565b7f41756374696f6e20686173206e6f7420656e6465640000000000000000000000600082015250565b60006140e7601583613cbd565b91506140f2826140b1565b602082019050919050565b60006020820190508181036000830152614116816140da565b9050919050565b7f4e6f206269647300000000000000000000000000000000000000000000000000600082015250565b6000614153600783613cbd565b915061415e8261411d565b602082019050919050565b6000602082019050818103600083015261418281614146565b9050919050565b60008151905061419881613338565b92915050565b6000602082840312156141b4576141b3613203565b5b60006141c284828501614189565b91505092915050565b6141d48161332a565b82525050565b6141e38161332a565b82525050565b6141f28161326b565b82525050565b60a08201600082015161420e6000850182613fce565b5060208201516142216020850182613fce565b50604082015161423460408501826141da565b5060608201516142476060850182613fce565b50608082015161425a60808501826141e9565b50505050565b60006101608201905061427660008301896141cb565b61428360208301886137d1565b61429060408301876136c3565b61429d60608301866141f8565b8181036101008301526142b0818561356d565b90506142c061012083018461402e565b979650505050505050565b60006142d6826137c1565b915063ffffffff82036142ec576142eb613e38565b5b600182019050919050565b60006143028261326b565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361433457614333613e38565b5b600182019050919050565b60006020828403121561435557614354613203565b5b600061436384828501613c24565b91505092915050565b614375816137c1565b82525050565b606082016000820151614391600085018261436c565b5060208201516143a46020850182613fce565b5060408201516143b760408501826141e9565b50505050565b60006080820190506143d2600083018561437b565b6143df60608301846141cb565b9392505050565b600060a0820190506143fb60008301876141cb565b61440860208301866137d1565b61441560408301856136c3565b614422606083018461402e565b95945050505050565b7f41756374696f6e206973206e6f7420736574746c656400000000000000000000600082015250565b6000614461601683613cbd565b915061446c8261442b565b602082019050919050565b6000602082019050818103600083015261449081614454565b9050919050565b7f4f6e6c792077696e6e65722063616e20636c61696d20746f6b656e0000000000600082015250565b60006144cd601b83613cbd565b91506144d882614497565b602082019050919050565b600060208201905081810360008301526144fc816144c0565b9050919050565b600060208201905061451860008301846137a3565b92915050565b600061453161452c846139c9565b61342d565b90508281526020810184848401111561454d5761454c6139c4565b5b61455884828561353a565b509392505050565b600082601f830112614575576145746139bf565b5b815161458584826020860161451e565b91505092915050565b6000602082840312156145a4576145a3613203565b5b600082015167ffffffffffffffff8111156145c2576145c1613208565b5b6145ce84828501614560565b91505092915050565b600067ffffffffffffffff8211156145f2576145f16133cd565b5b6145fb826133bc565b9050602081019050919050565b600061461b614616846145d7565b61342d565b905082815260208101848484011115614637576146366139c4565b5b61464284828561353a565b509392505050565b600082601f83011261465f5761465e6139bf565b5b815161466f848260208601614608565b91505092915050565b60006020828403121561468e5761468d613203565b5b600082015167ffffffffffffffff8111156146ac576146ab613208565b5b6146b88482850161464a565b91505092915050565b600081519050919050565b60006146d7826146c1565b6146e18185613cbd565b93506146f181856020860161353a565b6146fa816133bc565b840191505092915050565b6000602082019050818103600083015261471f81846146cc565b905092915050565b6000819050919050565b6000819050919050565b600061475661475161474c84614727565b614731565b61332a565b9050919050565b6147668161473b565b82525050565b6000602082019050614781600083018461475d565b92915050565b600060808201905061479c60008301876137a3565b6147a960208301866137a3565b6147b660408301856136c3565b81810360608301526147c8818461356d565b905095945050505050565b600060e0820190506147e860008301866137d1565b6147f560208301856141f8565b81810360c0830152614807818461356d565b9050949350505050565b7f416c726561647920696e697469616c697a656400000000000000000000000000600082015250565b6000614847601383613cbd565b915061485282614811565b602082019050919050565b600060208201905081810360008301526148768161483a565b9050919050565b600081905092915050565b60006148938261351e565b61489d818561487d565b93506148ad81856020860161353a565b80840191505092915050565b60006148c58284614888565b915081905092915050565b7f496e697469616c697a6174696f6e206f6620436f6e666964656e7469616c436f60008201527f6e74726f6c206661696c65640000000000000000000000000000000000000000602082015250565b600061492c602c83613cbd565b9150614937826148d0565b604082019050919050565b6000602082019050818103600083015261495b8161491f565b9050919050565b7f4f6e6c792061756374696f6e206d61737465722063616e2063616e63656c0000600082015250565b6000614998601e83613cbd565b91506149a382614962565b602082019050919050565b600060208201905081810360008301526149c78161498b565b9050919050565b6000815190506149dd816135d2565b92915050565b6000602082840312156149f9576149f8613203565b5b6000614a07848285016149ce565b91505092915050565b6000604082019050614a2560008301856137b2565b614a3260208301846137a3565b9392505050565b6000614a448261326b565b9150614a4f8361326b565b925082821015614a6257614a61613e38565b5b828203905092915050565b6000606082019050614a8260008301866136c3565b614a8f60208301856137e0565b614a9c60408301846137e0565b949350505050565b50565b6000614ab460008361487d565b9150614abf82614aa4565b600082019050919050565b6000614ad582614aa7565b9150819050919050565b6000604082019050614af460008301856136c3565b8181036020830152614b06818461356d565b90509392505050565b6000614b1a8261326b565b9150614b258361326b565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115614b5a57614b59613e38565b5b828201905092915050565b6000602082019050614b7a60008301846141cb565b92915050565b600067ffffffffffffffff821115614b9b57614b9a6133cd565b5b602082029050602081019050919050565b600080fd5b600081519050614bc08161387c565b92915050565b600081519050614bd58161323f565b92915050565b600060608284031215614bf157614bf06133b7565b5b614bfb606061342d565b90506000614c0b84828501614bb1565b6000830152506020614c1f84828501614bc6565b6020830152506040614c3384828501613c24565b60408301525092915050565b6000614c52614c4d84614b80565b61342d565b90508083825260208201905060608402830185811115614c7557614c74614bac565b5b835b81811015614c9e5780614c8a8882614bdb565b845260208401935050606081019050614c77565b5050509392505050565b600082601f830112614cbd57614cbc6139bf565b5b8151614ccd848260208601614c3f565b91505092915050565b600060208284031215614cec57614ceb613203565b5b600082015167ffffffffffffffff811115614d0a57614d09613208565b5b614d1684828501614ca8565b91505092915050565b600060a082019050614d3460008301846141f8565b92915050565b6000819050919050565b614d55614d50826135c8565b614d3a565b82525050565b6000614d678284614d44565b60208201915081905092915050565b6000602082019050614d8b60008301846137b2565b92915050565b6000614d9c8261332a565b9150614da78361332a565b92508261ffff03821115614dbe57614dbd613e38565b5b828201905092915050565b6000604082019050614dde60008301856137a3565b614deb60208301846141cb565b9392505050565b60028110614e0357614e0261371a565b5b50565b6000819050614e1482614df2565b919050565b6000614e2482614e06565b9050919050565b614e3481614e19565b82525050565b6000602082019050614e4f6000830184614e2b565b92915050565b7f796f000000000000000000000000000000000000000000000000000000000000600082015250565b6000614e8b600283613cbd565b9150614e9682614e55565b602082019050919050565b60006020820190508181036000830152614eba81614e7e565b9050919050565b600060ff82169050919050565b614ed781614ec1565b82525050565b6000602082019050614ef26000830184614ece565b92915050565b60006060820190508181036000830152614f12818661356d565b9050614f216020830185614e2b565b8181036040830152614f3381846146cc565b9050949350505050565b6000608082019050614f5260008301876137b2565b614f5f6020830186614ece565b614f6c60408301856137b2565b614f7960608301846137b2565b95945050505050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000614fba8383613fce565b60208301905092915050565b6000602082019050919050565b6000614fde82614f82565b614fe88185614f8d565b9350614ff383614f9e565b8060005b8381101561502457815161500b8882614fae565b975061501683614fc6565b925050600181019050614ff7565b5085935050505092915050565b600060808201905061504660008301876137e0565b81810360208301526150588186614fd3565b9050818103604083015261506c8185614fd3565b9050818103606083015261508081846146cc565b905095945050505050565b600067ffffffffffffffff8211156150a6576150a56133cd565b5b602082029050602081019050919050565b60006150ca6150c58461508b565b61342d565b905080838252602082019050602084028301858111156150ed576150ec614bac565b5b835b8181101561511657806151028882614bc6565b8452602084019350506020810190506150ef565b5050509392505050565b600082601f830112615135576151346139bf565b5b81516151458482602086016150b7565b91505092915050565b600060c08284031215615164576151636133b7565b5b61516e60c061342d565b9050600061517e84828501613f7d565b600083015250602061519284828501613f7d565b60208301525060406151a684828501613c39565b604083015250606082015167ffffffffffffffff8111156151ca576151c9613448565b5b6151d684828501615120565b606083015250608082015167ffffffffffffffff8111156151fa576151f9613448565b5b61520684828501615120565b60808301525060a082015167ffffffffffffffff81111561522a57615229613448565b5b6152368482850161464a565b60a08301525092915050565b60006020828403121561525857615257613203565b5b600082015167ffffffffffffffff81111561527657615275613208565b5b6152828482850161514e565b91505092915050565b60006060820190506152a060008301866137a3565b81810360208301526152b281856146cc565b905081810360408301526152c6818461356d565b9050949350505050565b6152d98161326b565b82525050565b60006040820190506152f460008301856137b2565b61530160208301846152d0565b9392505050565b7f696e76616c6964207369676e6174757265206c656e6774680000000000000000600082015250565b600061533e601883613cbd565b915061534982615308565b602082019050919050565b6000602082019050818103600083015261536d81615331565b9050919050565b600061537f82614ec1565b915061538a83614ec1565b92508260ff038211156153a05761539f613e38565b5b828201905092915050565b60006040820190506153c060008301856137a3565b81810360208301526153d281846146cc565b9050939250505056fea2646970667358221220abef89796bef41344cf8ef8b2f71e4e04ed410da28fe796bb847f64fe30a261664736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2007,
        "contract": "contracts/Auction.sol:TokenAuction",
        "label": "secretBidId",
        "offset": 0,
        "slot": "0",
        "type": "t_userDefinedValueType(DataId)11163"
      },
      {
        "astId": 2009,
        "contract": "contracts/Auction.sol:TokenAuction",
        "label": "presentHash",
        "offset": 0,
        "slot": "1",
        "type": "t_bytes32"
      },
      {
        "astId": 2011,
        "contract": "contracts/Auction.sol:TokenAuction",
        "label": "nonce",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 29,
        "contract": "contracts/Auction.sol:TokenAuction",
        "label": "vault",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      },
      {
        "astId": 31,
        "contract": "contracts/Auction.sol:TokenAuction",
        "label": "auctionMaster",
        "offset": 0,
        "slot": "4",
        "type": "t_address"
      },
      {
        "astId": 35,
        "contract": "contracts/Auction.sol:TokenAuction",
        "label": "auctions",
        "offset": 0,
        "slot": "5",
        "type": "t_array(t_struct(Auction)1809_storage)dyn_storage"
      },
      {
        "astId": 37,
        "contract": "contracts/Auction.sol:TokenAuction",
        "label": "isInitialized",
        "offset": 0,
        "slot": "6",
        "type": "t_bool"
      },
      {
        "astId": 40,
        "contract": "contracts/Auction.sol:TokenAuction",
        "label": "vaultRemote",
        "offset": 1,
        "slot": "6",
        "type": "t_contract(ISettlementVault)1780"
      },
      {
        "astId": 43,
        "contract": "contracts/Auction.sol:TokenAuction",
        "label": "pkDataId",
        "offset": 0,
        "slot": "7",
        "type": "t_userDefinedValueType(DataId)11163"
      },
      {
        "astId": 46,
        "contract": "contracts/Auction.sol:TokenAuction",
        "label": "bidCountDataId",
        "offset": 16,
        "slot": "7",
        "type": "t_userDefinedValueType(DataId)11163"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_struct(Auction)1809_storage)dyn_storage": {
        "base": "t_struct(Auction)1809_storage",
        "encoding": "dynamic_array",
        "label": "struct Auction[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(ISettlementVault)1780": {
        "encoding": "inplace",
        "label": "contract ISettlementVault",
        "numberOfBytes": "20"
      },
      "t_enum(AuctionStatus)1788": {
        "encoding": "inplace",
        "label": "enum AuctionStatus",
        "numberOfBytes": "1"
      },
      "t_struct(Auction)1809_storage": {
        "encoding": "inplace",
        "label": "struct Auction",
        "members": [
          {
            "astId": 1790,
            "contract": "contracts/Auction.sol:TokenAuction",
            "label": "payoutAddress",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 1793,
            "contract": "contracts/Auction.sol:TokenAuction",
            "label": "status",
            "offset": 20,
            "slot": "0",
            "type": "t_enum(AuctionStatus)1788"
          },
          {
            "astId": 1796,
            "contract": "contracts/Auction.sol:TokenAuction",
            "label": "tokenDataId",
            "offset": 0,
            "slot": "1",
            "type": "t_userDefinedValueType(DataId)11163"
          },
          {
            "astId": 1798,
            "contract": "contracts/Auction.sol:TokenAuction",
            "label": "hashedToken",
            "offset": 0,
            "slot": "2",
            "type": "t_bytes32"
          },
          {
            "astId": 1800,
            "contract": "contracts/Auction.sol:TokenAuction",
            "label": "bids",
            "offset": 0,
            "slot": "3",
            "type": "t_uint32"
          },
          {
            "astId": 1802,
            "contract": "contracts/Auction.sol:TokenAuction",
            "label": "until",
            "offset": 4,
            "slot": "3",
            "type": "t_uint64"
          },
          {
            "astId": 1804,
            "contract": "contracts/Auction.sol:TokenAuction",
            "label": "payoutCollectionDuration",
            "offset": 12,
            "slot": "3",
            "type": "t_uint64"
          },
          {
            "astId": 1806,
            "contract": "contracts/Auction.sol:TokenAuction",
            "label": "auctioneer",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 1808,
            "contract": "contracts/Auction.sol:TokenAuction",
            "label": "winner",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_userDefinedValueType(DataId)11163": {
        "encoding": "inplace",
        "label": "Suave.DataId",
        "numberOfBytes": "16"
      }
    }
  }
}