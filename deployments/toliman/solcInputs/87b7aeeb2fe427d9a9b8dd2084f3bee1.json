{
  "language": "Solidity",
  "sources": {
    "contracts/lib/AuctionUtils.sol": {
      "content": "pragma solidity ^0.8.8;\n\n\ntype BidId is uint256;\n\nenum AuctionStatus {\n    LIVE,\n    CANCELLED,\n    SETTLED\n}\n\nstruct Auction {\n    AuctionStatus status;\n    uint128 bids;\n    address payoutAddress;\n    bytes32 hashedToken;\n    uint64 until;\n    uint64 payoutCollectionDuration;\n    address auctioneer;\n}\nstruct Bid {\n    BidId id;\n    address bidder;\n    uint256 amount;\n}\nstruct NewAuctionArgs {\n    uint64 auctionDuration;\n    uint64 payoutCollectionDuration;\n    address payoutAddress;\n}\nstruct AuctionPayout {\n    address account;\n    uint amount;\n}\n\nlibrary BidUtils {\n\n    function getBidId(uint128 auctionId, uint128 bidIndex) internal pure returns (BidId) {\n        return BidId.wrap(uint(auctionId << 128 | bidIndex));\n    }\n\n    function unpackBidId(BidId bidId) internal pure returns (uint128 auctionId, uint128 bidIndex) {\n        auctionId = uint128(BidId.unwrap(bidId)) >> 128;\n        bidIndex = uint128(BidId.unwrap(bidId));\n    }\n\n}"
    },
    "contracts/lib/SigUtils.sol": {
      "content": "pragma solidity ^0.8.8;\n\nimport { Suave } from \"lib/suave-std/src/suavelib/Suave.sol\";\n\n\nfunction getAddressForPk(string memory pk) returns (address) {\n    bytes32 digest = keccak256(abi.encode(\"yo\"));\n    bytes memory sig = Suave.signMessage(abi.encodePacked(digest), Suave.CryptoSignature.SECP256, pk);\n    return recoverSigner(digest, sig);\n}\n\nfunction recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) pure returns (address) {\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n    return ecrecover(_ethSignedMessageHash, v, r, s);\n}\n\nfunction splitSignature(bytes memory sig) pure returns (bytes32 r, bytes32 s, uint8 v) {\n    require(sig.length == 65, \"invalid signature length\");\n    assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n    }\n    if (v < 27) {\n        v += 27;\n    }\n}"
    },
    "contracts/SettlementVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n\nimport { AuctionPayout } from \"./lib/AuctionUtils.sol\";\nimport \"./lib/SigUtils.sol\";\n\n\ncontract SettlementVault {\n\n    event Locked(address indexed account, uint192 amount, uint64 unlockTimestamp);\n    event ScheduledUnlock(address indexed account, uint64 unlockTimestamp);\n    event Withdrawn(address indexed account, uint192 amount);\n    event FundsTaken(address indexed account, uint192 amount, address indexed to);\n\n    struct AccountBalance {\n        uint64 unlockTimestamp;\n        uint192 balance;\n    }\n\n    bytes32 public constant TAKER_ROLE = keccak256(\"TAKER_ROLE\");\n    uint64 immutable withdrawPeriod = 1 days;\n    mapping(address => AccountBalance) internal _balances;\n    address immutable owner = msg.sender;\n    address public auctionMaster;\n\n    function registerAuctionMaster(address _auctionMaster) external {\n        require(auctionMaster == address(0), \"Auction master already set\");\n        require(msg.sender == auctionMaster, \"Unauthorized\");\n        auctionMaster = _auctionMaster;\n    }\n\n    function getBalance(address account) external view returns (uint256, uint64) {\n        return (_balances[account].balance, _balances[account].unlockTimestamp);\n    }\n\n    function lock() external payable {\n        require(msg.value > 0, \"Value must be greater than 0\");\n        _balances[msg.sender] = AccountBalance(type(uint64).max, uint192(msg.value));\n        emit Locked(msg.sender, uint192(msg.value), type(uint64).max);\n    }\n\n    function scheduleUnlock() external {\n        require(_balances[msg.sender].unlockTimestamp > 0, \"No funds locked\");\n        uint64 newUnlockTimestamp = uint64(block.timestamp) + withdrawPeriod;\n        _balances[msg.sender].unlockTimestamp = newUnlockTimestamp ;\n        emit ScheduledUnlock(msg.sender, newUnlockTimestamp);\n    }\n\n    function withdraw() external {\n        AccountBalance memory bal = _balances[msg.sender];\n        require(bal.unlockTimestamp <= block.timestamp, \"Funds are still locked\");\n        _balances[msg.sender] = AccountBalance(0, 0);\n        uint192 amount = bal.balance;\n        _nativeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function takeFunds(address account, uint192 amount, address to, bytes memory payoutSignature) external {\n        _verifySignature(AuctionPayout(account, amount), payoutSignature);\n        require(_balances[account].balance >= amount, \"Insufficient funds\");\n        unchecked { _balances[account].balance -= amount; }\n        _nativeTransfer(msg.sender, amount);\n        emit FundsTaken(account, amount, to);\n    }\n\n    function _nativeTransfer(address to, uint192 amount) internal {\n        (bool success,) = to.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function _verifySignature(\n        AuctionPayout memory payout, \n        bytes memory signature\n    ) internal view {\n        bytes32 digest = keccak256(abi.encode(payout));\n        address signer = recoverSigner(digest, signature);\n        require(signer == auctionMaster, \"Invalid signature\");\n    }\n\n}"
    },
    "lib/suave-std/src/suavelib/Suave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.8;\n\n/// @notice Library to interact with the Suave MEVM precompiles.\nlibrary Suave {\n    error PeekerReverted(address, bytes);\n\n    enum CryptoSignature {\n        SECP256,\n        BLS\n    }\n\n    type DataId is bytes16;\n\n    /// @notice Arguments to build the block.\n    /// @param slot Slot number of the block\n    /// @param proposerPubkey Public key of the proposer\n    /// @param parent Hash of the parent block\n    /// @param timestamp Timestamp of the block\n    /// @param feeRecipient Address of the fee recipient\n    /// @param gasLimit Gas limit of the block\n    /// @param random Randomness of the block\n    /// @param withdrawals List of withdrawals\n    /// @param extra Extra data of the block\n    /// @param beaconRoot Root of the beacon chain\n    /// @param fillPending Whether to fill the block with pending transactions\n    struct BuildBlockArgs {\n        uint64 slot;\n        bytes proposerPubkey;\n        bytes32 parent;\n        uint64 timestamp;\n        address feeRecipient;\n        uint64 gasLimit;\n        bytes32 random;\n        Withdrawal[] withdrawals;\n        bytes extra;\n        bytes32 beaconRoot;\n        bool fillPending;\n    }\n\n    /// @notice A record of data stored in the ConfidentialStore.\n    /// @param id ID of the data record\n    /// @param salt Salt used to derive the encryption key\n    /// @param decryptionCondition Up to which block this data record is valid\n    /// @param allowedPeekers Addresses which can get data\n    /// @param allowedStores Addresses can set data\n    /// @param version Namespace of the data record\n    struct DataRecord {\n        DataId id;\n        DataId salt;\n        uint64 decryptionCondition;\n        address[] allowedPeekers;\n        address[] allowedStores;\n        string version;\n    }\n\n    /// @notice Description of an HTTP request.\n    /// @param url Target url of the request\n    /// @param method HTTP method of the request\n    /// @param headers HTTP Headers\n    /// @param body Body of the request (if Post or Put)\n    /// @param withFlashbotsSignature Whether to include the Flashbots signature\n    /// @param timeout Timeout of the request in milliseconds\n    struct HttpRequest {\n        string url;\n        string method;\n        string[] headers;\n        bytes body;\n        bool withFlashbotsSignature;\n        uint64 timeout;\n    }\n\n    /// @notice Result of a simulated transaction.\n    /// @param egp Effective Gas Price of the transaction\n    /// @param logs Logs emitted during the simulation\n    /// @param success Whether the transaction was successful or not\n    /// @param error Error message if any\n    struct SimulateTransactionResult {\n        uint64 egp;\n        SimulatedLog[] logs;\n        bool success;\n        string error;\n    }\n\n    /// @notice A log emitted during the simulation of a transaction.\n    /// @param data Data of the log\n    /// @param addr Address of the contract that emitted the log\n    /// @param topics Topics of the log\n    struct SimulatedLog {\n        bytes data;\n        address addr;\n        bytes32[] topics;\n    }\n\n    /// @notice A withdrawal from the beacon chain.\n    /// @param index Index of the withdrawal\n    /// @param validator ID of the validator\n    /// @param Address Address to withdraw to\n    /// @param amount Amount to be withdrawn\n    struct Withdrawal {\n        uint64 index;\n        uint64 validator;\n        address Address;\n        uint64 amount;\n    }\n\n    address public constant ANYALLOWED = 0xC8df3686b4Afb2BB53e60EAe97EF043FE03Fb829;\n\n    address public constant IS_CONFIDENTIAL_ADDR = 0x0000000000000000000000000000000042010000;\n\n    address public constant BUILD_ETH_BLOCK = 0x0000000000000000000000000000000042100001;\n\n    address public constant BUILD_ETH_BLOCK_TO = 0x0000000000000000000000000000000042100006;\n\n    address public constant CONFIDENTIAL_INPUTS = 0x0000000000000000000000000000000042010001;\n\n    address public constant CONFIDENTIAL_RETRIEVE = 0x0000000000000000000000000000000042020001;\n\n    address public constant CONFIDENTIAL_STORE = 0x0000000000000000000000000000000042020000;\n\n    address public constant CONTEXT_GET = 0x0000000000000000000000000000000053300003;\n\n    address public constant DO_HTTPREQUEST = 0x0000000000000000000000000000000043200002;\n\n    address public constant ETHCALL = 0x0000000000000000000000000000000042100003;\n\n    address public constant EXTRACT_HINT = 0x0000000000000000000000000000000042100037;\n\n    address public constant FETCH_DATA_RECORDS = 0x0000000000000000000000000000000042030001;\n\n    address public constant FILL_MEV_SHARE_BUNDLE = 0x0000000000000000000000000000000043200001;\n\n    address public constant NEW_BUILDER = 0x0000000000000000000000000000000053200001;\n\n    address public constant NEW_DATA_RECORD = 0x0000000000000000000000000000000042030000;\n\n    address public constant PRIVATE_KEY_GEN = 0x0000000000000000000000000000000053200003;\n\n    address public constant RANDOM_BYTES = 0x000000000000000000000000000000007770000b;\n\n    address public constant SIGN_ETH_TRANSACTION = 0x0000000000000000000000000000000040100001;\n\n    address public constant SIGN_MESSAGE = 0x0000000000000000000000000000000040100003;\n\n    address public constant SIMULATE_BUNDLE = 0x0000000000000000000000000000000042100000;\n\n    address public constant SIMULATE_TRANSACTION = 0x0000000000000000000000000000000053200002;\n\n    address public constant SUBMIT_BUNDLE_JSON_RPC = 0x0000000000000000000000000000000043000001;\n\n    address public constant SUBMIT_ETH_BLOCK_TO_RELAY = 0x0000000000000000000000000000000042100002;\n\n    /// @notice Returns whether execution is off- or on-chain\n    /// @return b Whether execution is off- or on-chain\n    function isConfidential() internal returns (bool b) {\n        (bool success, bytes memory isConfidentialBytes) = IS_CONFIDENTIAL_ADDR.call(\"\");\n        if (!success) {\n            revert PeekerReverted(IS_CONFIDENTIAL_ADDR, isConfidentialBytes);\n        }\n        assembly {\n            // Load the length of data (first 32 bytes)\n            let len := mload(isConfidentialBytes)\n            // Load the data after 32 bytes, so add 0x20\n            b := mload(add(isConfidentialBytes, 0x20))\n        }\n    }\n\n    /// @notice Constructs an Ethereum block based on the provided data records. No blobs are returned.\n    /// @param blockArgs Arguments to build the block\n    /// @param dataId ID of the data record with mev-share bundle data\n    /// @param relayUrl If specified the built block will be submitted to the relay\n    /// @return blockBid Block Bid encoded in JSON\n    /// @return executionPayload Execution payload encoded in JSON\n    function buildEthBlock(BuildBlockArgs memory blockArgs, DataId dataId, string memory relayUrl)\n        internal\n        returns (bytes memory, bytes memory)\n    {\n        (bool success, bytes memory data) = BUILD_ETH_BLOCK.call(abi.encode(blockArgs, dataId, relayUrl));\n        if (!success) {\n            revert PeekerReverted(BUILD_ETH_BLOCK, data);\n        }\n\n        return abi.decode(data, (bytes, bytes));\n    }\n\n    /// @notice Constructs an Ethereum block based on the provided data records. No blobs are returned.\n    /// @param executionNodeURL URL (or service name) of the execution node\n    /// @param blockArgs Arguments to build the block\n    /// @param dataId ID of the data record with mev-share bundle data\n    /// @param relayUrl If specified the built block will be submitted to the relay\n    /// @return blockBid Block Bid encoded in JSON\n    /// @return executionPayload Execution payload encoded in JSON\n    function buildEthBlockTo(\n        string memory executionNodeURL,\n        BuildBlockArgs memory blockArgs,\n        DataId dataId,\n        string memory relayUrl\n    ) internal returns (bytes memory, bytes memory) {\n        (bool success, bytes memory data) =\n            BUILD_ETH_BLOCK_TO.call(abi.encode(executionNodeURL, blockArgs, dataId, relayUrl));\n        if (!success) {\n            revert PeekerReverted(BUILD_ETH_BLOCK_TO, data);\n        }\n\n        return abi.decode(data, (bytes, bytes));\n    }\n\n    /// @notice Provides the confidential inputs associated with a confidential computation request. Outputs are in bytes format.\n    /// @return confindentialData Confidential inputs\n    function confidentialInputs() internal returns (bytes memory) {\n        (bool success, bytes memory data) = CONFIDENTIAL_INPUTS.call(abi.encode());\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_INPUTS, data);\n        }\n\n        return data;\n    }\n\n    /// @notice Retrieves data from the confidential store. Also mandates the caller's presence in the `AllowedPeekers` list.\n    /// @param dataId ID of the data record to retrieve\n    /// @param key Key slot of the data to retrieve\n    /// @return value Value of the data\n    function confidentialRetrieve(DataId dataId, string memory key) internal returns (bytes memory) {\n        (bool success, bytes memory data) = CONFIDENTIAL_RETRIEVE.call(abi.encode(dataId, key));\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_RETRIEVE, data);\n        }\n\n        return data;\n    }\n\n    /// @notice Stores data in the confidential store. Requires the caller to be part of the `AllowedPeekers` for the associated data record.\n    /// @param dataId ID of the data record to store\n    /// @param key Key slot of the data to store\n    /// @param value Value of the data to store\n    function confidentialStore(DataId dataId, string memory key, bytes memory value) internal {\n        (bool success, bytes memory data) = CONFIDENTIAL_STORE.call(abi.encode(dataId, key, value));\n        if (!success) {\n            revert PeekerReverted(CONFIDENTIAL_STORE, data);\n        }\n    }\n\n    /// @notice Retrieves a value from the context\n    /// @param key Key of the value to retrieve\n    /// @return value Value of the key\n    function contextGet(string memory key) internal returns (bytes memory) {\n        (bool success, bytes memory data) = CONTEXT_GET.call(abi.encode(key));\n        if (!success) {\n            revert PeekerReverted(CONTEXT_GET, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    /// @notice Performs an HTTP request and returns the response. `request` is the request to perform.\n    /// @param request Request to perform\n    /// @return httpResponse Body of the response\n    function doHTTPRequest(HttpRequest memory request) internal returns (bytes memory) {\n        (bool success, bytes memory data) = DO_HTTPREQUEST.call(abi.encode(request));\n        if (!success) {\n            revert PeekerReverted(DO_HTTPREQUEST, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    /// @notice Uses the `eth_call` JSON RPC method to let you simulate a function call and return the response.\n    /// @param contractAddr Address of the contract to call\n    /// @param input1 Data to send to the contract\n    /// @return callOutput Output of the contract call\n    function ethcall(address contractAddr, bytes memory input1) internal returns (bytes memory) {\n        (bool success, bytes memory data) = ETHCALL.call(abi.encode(contractAddr, input1));\n        if (!success) {\n            revert PeekerReverted(ETHCALL, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    /// @notice Interprets the bundle data and extracts hints, such as the `To` address and calldata.\n    /// @param bundleData Bundle object encoded in JSON\n    /// @return hints List of hints encoded in JSON\n    function extractHint(bytes memory bundleData) internal returns (bytes memory) {\n        require(isConfidential());\n        (bool success, bytes memory data) = EXTRACT_HINT.call(abi.encode(bundleData));\n        if (!success) {\n            revert PeekerReverted(EXTRACT_HINT, data);\n        }\n\n        return data;\n    }\n\n    /// @notice Retrieves all data records correlating with a specified decryption condition and namespace\n    /// @param cond Filter for the decryption condition\n    /// @param namespace Filter for the namespace of the data records\n    /// @return dataRecords List of data records that match the filter\n    function fetchDataRecords(uint64 cond, string memory namespace) internal returns (DataRecord[] memory) {\n        (bool success, bytes memory data) = FETCH_DATA_RECORDS.call(abi.encode(cond, namespace));\n        if (!success) {\n            revert PeekerReverted(FETCH_DATA_RECORDS, data);\n        }\n\n        return abi.decode(data, (DataRecord[]));\n    }\n\n    /// @notice Joins the user's transaction and with the backrun, and returns encoded mev-share bundle. The bundle is ready to be sent via `SubmitBundleJsonRPC`.\n    /// @param dataId ID of the data record with mev-share bundle data\n    /// @return encodedBundle Mev-Share bundle encoded in JSON\n    function fillMevShareBundle(DataId dataId) internal returns (bytes memory) {\n        require(isConfidential());\n        (bool success, bytes memory data) = FILL_MEV_SHARE_BUNDLE.call(abi.encode(dataId));\n        if (!success) {\n            revert PeekerReverted(FILL_MEV_SHARE_BUNDLE, data);\n        }\n\n        return data;\n    }\n\n    /// @notice Initializes a new remote builder session\n    /// @return sessionid ID of the remote builder session\n    function newBuilder() internal returns (string memory) {\n        (bool success, bytes memory data) = NEW_BUILDER.call(abi.encode());\n        if (!success) {\n            revert PeekerReverted(NEW_BUILDER, data);\n        }\n\n        return abi.decode(data, (string));\n    }\n\n    /// @notice Initializes data records within the ConfidentialStore. Prior to storing data, all data records should undergo initialization via this precompile.\n    /// @param decryptionCondition Up to which block this data record is valid. Used during `fillMevShareBundle` precompie.\n    /// @param allowedPeekers Addresses which can get data\n    /// @param allowedStores Addresses can set data\n    /// @param dataType Namespace of the data\n    /// @return dataRecord Data record that was created\n    function newDataRecord(\n        uint64 decryptionCondition,\n        address[] memory allowedPeekers,\n        address[] memory allowedStores,\n        string memory dataType\n    ) internal returns (DataRecord memory) {\n        (bool success, bytes memory data) =\n            NEW_DATA_RECORD.call(abi.encode(decryptionCondition, allowedPeekers, allowedStores, dataType));\n        if (!success) {\n            revert PeekerReverted(NEW_DATA_RECORD, data);\n        }\n\n        return abi.decode(data, (DataRecord));\n    }\n\n    /// @notice Generates a private key in ECDA secp256k1 format\n    /// @param crypto Type of the private key to generate\n    /// @return privateKey Hex encoded string of the ECDSA private key. Exactly as a signMessage precompile wants.\n    function privateKeyGen(CryptoSignature crypto) internal returns (string memory) {\n        (bool success, bytes memory data) = PRIVATE_KEY_GEN.call(abi.encode(crypto));\n        if (!success) {\n            revert PeekerReverted(PRIVATE_KEY_GEN, data);\n        }\n\n        return abi.decode(data, (string));\n    }\n\n    /// @notice Generates a number of random bytes, given by the argument numBytes.\n    /// @param numBytes Number of random bytes to generate\n    /// @return value Randomly-generated bytes\n    function randomBytes(uint8 numBytes) internal returns (bytes memory) {\n        (bool success, bytes memory data) = RANDOM_BYTES.call(abi.encode(numBytes));\n        if (!success) {\n            revert PeekerReverted(RANDOM_BYTES, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    /// @notice Signs an Ethereum Transaction, 1559 or Legacy, and returns raw signed transaction bytes. `txn` is binary encoding of the transaction.\n    /// @param txn Transaction to sign (RLP encoded)\n    /// @param chainId Id of the chain to sign for (hex encoded, with 0x prefix)\n    /// @param signingKey Hex encoded string of the ECDSA private key (without 0x prefix)\n    /// @return signedTxn Signed transaction encoded in RLP\n    function signEthTransaction(bytes memory txn, string memory chainId, string memory signingKey)\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory data) = SIGN_ETH_TRANSACTION.call(abi.encode(txn, chainId, signingKey));\n        if (!success) {\n            revert PeekerReverted(SIGN_ETH_TRANSACTION, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    /// @notice Signs a message and returns the signature.\n    /// @param digest Message to sign\n    /// @param crypto Type of the private key to generate\n    /// @param signingKey Hex encoded string of the ECDSA private key\n    /// @return signature Signature of the message with the private key\n    function signMessage(bytes memory digest, CryptoSignature crypto, string memory signingKey)\n        internal\n        returns (bytes memory)\n    {\n        require(isConfidential());\n        (bool success, bytes memory data) = SIGN_MESSAGE.call(abi.encode(digest, crypto, signingKey));\n        if (!success) {\n            revert PeekerReverted(SIGN_MESSAGE, data);\n        }\n\n        return abi.decode(data, (bytes));\n    }\n\n    /// @notice Performs a simulation of the bundle by building a block that includes it.\n    /// @param bundleData Bundle encoded in JSON\n    /// @return effectiveGasPrice Effective Gas Price of the resultant block\n    function simulateBundle(bytes memory bundleData) internal returns (uint64) {\n        (bool success, bytes memory data) = SIMULATE_BUNDLE.call(abi.encode(bundleData));\n        if (!success) {\n            revert PeekerReverted(SIMULATE_BUNDLE, data);\n        }\n\n        return abi.decode(data, (uint64));\n    }\n\n    /// @notice Simulates a transaction on a remote builder session\n    /// @param sessionid ID of the remote builder session\n    /// @param txn Txn to simulate encoded in RLP\n    /// @return simulationResult Result of the simulation\n    function simulateTransaction(string memory sessionid, bytes memory txn)\n        internal\n        returns (SimulateTransactionResult memory)\n    {\n        (bool success, bytes memory data) = SIMULATE_TRANSACTION.call(abi.encode(sessionid, txn));\n        if (!success) {\n            revert PeekerReverted(SIMULATE_TRANSACTION, data);\n        }\n\n        return abi.decode(data, (SimulateTransactionResult));\n    }\n\n    /// @notice Submits bytes as JSONRPC message to the specified URL with the specified method. As this call is intended for bundles, it also signs the params and adds `X-Flashbots-Signature` header, as usual with bundles. Regular eth bundles don't need any processing to be sent.\n    /// @param url URL to send the request to\n    /// @param method JSONRPC method to call\n    /// @param params JSONRPC input params encoded in RLP\n    /// @return errorMessage Error message if any\n    function submitBundleJsonRPC(string memory url, string memory method, bytes memory params)\n        internal\n        returns (bytes memory)\n    {\n        require(isConfidential());\n        (bool success, bytes memory data) = SUBMIT_BUNDLE_JSON_RPC.call(abi.encode(url, method, params));\n        if (!success) {\n            revert PeekerReverted(SUBMIT_BUNDLE_JSON_RPC, data);\n        }\n\n        return data;\n    }\n\n    /// @notice Submits a given builderBid to a mev-boost relay.\n    /// @param relayUrl URL of the relay to submit to\n    /// @param builderBid Block bid to submit encoded in JSON\n    /// @return blockBid Error message if any\n    function submitEthBlockToRelay(string memory relayUrl, bytes memory builderBid) internal returns (bytes memory) {\n        require(isConfidential());\n        (bool success, bytes memory data) = SUBMIT_ETH_BLOCK_TO_RELAY.call(abi.encode(relayUrl, builderBid));\n        if (!success) {\n            revert PeekerReverted(SUBMIT_ETH_BLOCK_TO_RELAY, data);\n        }\n\n        return data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}